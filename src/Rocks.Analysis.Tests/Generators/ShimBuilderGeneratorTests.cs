using NUnit.Framework;

namespace Rocks.Analysis.Tests.Generators;

public static class ShimBuilderGeneratorTests
{
	[Test]
	public static async Task GenerateWhenShimHasInitPropertyAsync()
	{
		var code =
			"""
			using Rocks;
	
			[assembly: Rock(typeof(IBufferedChannel), BuildType.Create | BuildType.Make)]
	
			public interface IBufferedChannel
			{
				int MaxBufferSize { get; init; }
				void Consume(int count) { }
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IBufferedChannelCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<int>>
				{
					public global::Rocks.Argument<int> @count { get; set; }
				}
				private global::Rocks.Handlers<global::IBufferedChannelCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IBufferedChannelCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Action<int>>
				{
					public global::Rocks.Argument<int> @value { get; set; }
				}
				private global::Rocks.Handlers<global::IBufferedChannelCreateExpectations.Handler2>? @handlers2;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IBufferedChannelCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IBufferedChannel
				{
					private readonly global::IBufferedChannel shimForShimIBufferedChannel;
					public Mock(global::IBufferedChannelCreateExpectations @expectations, ConstructorProperties? @constructorProperties)
					{
						(this.Expectations, this.shimForShimIBufferedChannel) = (@expectations, new ShimIBufferedChannel(this));
						if (@constructorProperties is not null)
						{
							this.MaxBufferSize = @constructorProperties.MaxBufferSize;
						}
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Consume(int @count)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@count.IsValid(@count!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@count!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									No handlers match for {this.GetType().GetMemberDescription(0)}
										count: {@count.FormatValue()}
									""");
							}
						}
						else
						{
							this.shimForShimIBufferedChannel.Consume(@count: @count!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Get)]
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Set)]
					public int MaxBufferSize
					{
						get
						{
							if (this.Expectations.handlers1 is not null)
							{
								var @handler = this.Expectations.handlers1.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(1)}
								""");
						}
						init
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @foundMatch = false;
								foreach (var @handler in this.Expectations.handlers2)
								{
									if (@handler.value.IsValid(value!))
									{
										@handler.CallCount++;
										@foundMatch = true;
										@handler.Callback?.Invoke(value!);
										
										if (!@foundMatch)
										{
											this.Expectations.WasExceptionThrown = true;
											throw new global::Rocks.Exceptions.ExpectationException(
												$"""
												No handlers match for {this.GetType().GetMemberDescription(2)}
													value: {@value.FormatValue()}
												""");
										}
										
										break;
									}
								}
							}
							else
							{
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									No handlers were found for {this.GetType().GetMemberDescription(2)}
										value: {@value.FormatValue()}
									""");
							}
						}
					}
					
					
					private sealed class ShimIBufferedChannel
						: global::IBufferedChannel
					{
						private readonly Mock mock;
						
						public ShimIBufferedChannel(Mock @mock) =>
							this.mock = @mock;
						
						public int MaxBufferSize
						{
							get => ((global::IBufferedChannel)this.mock).MaxBufferSize!;
							init { }
						}
					}
					private global::IBufferedChannelCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IBufferedChannelCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IBufferedChannelCreateExpectations.Adornments.AdornmentsForHandler0 Consume(global::Rocks.Argument<int> @count)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@count);
						
						var @handler = new global::IBufferedChannelCreateExpectations.Handler0
						{
							@count = @count,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IBufferedChannelCreateExpectations Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IBufferedChannelCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IBufferedChannelCreateExpectations.Adornments.AdornmentsForHandler1 MaxBufferSize()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IBufferedChannelCreateExpectations.Handler1();
							if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
							else { this.Expectations.handlers1.Add(handler); }
							return new(handler);
						}
						private global::IBufferedChannelCreateExpectations Expectations { get; }
					}
					
					internal sealed class PropertyInitializerExpectations
					{
						internal PropertyInitializerExpectations(global::IBufferedChannelCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IBufferedChannelCreateExpectations.Adornments.AdornmentsForHandler2 MaxBufferSize(global::Rocks.Argument<int> @value)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@value);
						
							var handler = new global::IBufferedChannelCreateExpectations.Handler2
							{
								value = @value,
							};
						
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IBufferedChannelCreateExpectations Expectations { get; }
					}
					
					internal PropertyExpectations(global::IBufferedChannelCreateExpectations expectations) =>
						(this.Getters, this.Initializers) = (new(expectations), new(expectations));
					
					internal global::IBufferedChannelCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
					internal global::IBufferedChannelCreateExpectations.PropertyExpectations.PropertyInitializerExpectations Initializers { get; }
				}
				
				internal global::IBufferedChannelCreateExpectations.MethodExpectations Methods { get; }
				internal global::IBufferedChannelCreateExpectations.PropertyExpectations Properties { get; }
				
				public IBufferedChannelCreateExpectations() =>
					(this.Methods, this.Properties) = (new(this), new(this));
				
				internal sealed class ConstructorProperties
				{
					internal int MaxBufferSize { get; init; }
				}
				
				internal global::IBufferedChannel Instance(global::IBufferedChannelCreateExpectations.ConstructorProperties? @constructorProperties)
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @constructorProperties);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIBufferedChannel<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIBufferedChannel<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IBufferedChannelCreateExpectations.Handler0, global::System.Action<int>>, IAdornmentsForIBufferedChannel<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IBufferedChannelCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IBufferedChannelCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForIBufferedChannel<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IBufferedChannelCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IBufferedChannelCreateExpectations.Handler2, global::System.Action<int>>, IAdornmentsForIBufferedChannel<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IBufferedChannelCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IBufferedChannelMakeExpectations
			{
				internal sealed class ConstructorProperties
				{
					internal int MaxBufferSize { get; init; }
				}
				
				internal global::IBufferedChannel Instance(global::IBufferedChannelMakeExpectations.ConstructorProperties? @constructorProperties)
				{
					return new Mock(@constructorProperties);
				}
				
				private sealed class Mock
					: global::IBufferedChannel
				{
					public Mock(ConstructorProperties? @constructorProperties)
					{
						if (@constructorProperties is not null)
						{
							this.MaxBufferSize = @constructorProperties.MaxBufferSize;
						}
					}
					
					public void Consume(int @count)
					{
					}
					public int MaxBufferSize
					{
						get => default!;
						init { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			"""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IBufferedChannel_Rock_Create.g.cs", createGeneratedCode),
				("IBufferedChannel_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task GenerateWhenMultipleInterfacesShareSameNonGenericNameAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: Rock(typeof(IAuditTrail<>), BuildType.Create | BuildType.Make)]
			
			public interface IAuditTrail
			{
				void Work() { }
			}

			public interface IAuditTrail<T>
				: IAuditTrail
			{
				void Perform() { }
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IAuditTrailCreateExpectations<T>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::IAuditTrailCreateExpectations<T>.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::IAuditTrailCreateExpectations<T>.Handler1>? @handlers1;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IAuditTrailCreateExpectations<T> was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IAuditTrail<T>
				{
					private readonly global::IAuditTrail<T> shimForShimIAuditTrailT;
					private readonly global::IAuditTrail shimForShimIAuditTrail;
					public Mock(global::IAuditTrailCreateExpectations<T> @expectations)
					{
						(this.Expectations, this.shimForShimIAuditTrailT, this.shimForShimIAuditTrail) = (@expectations, new ShimIAuditTrailT(this), new ShimIAuditTrail(this));
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Perform()
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @handler = this.Expectations.handlers0.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							this.shimForShimIAuditTrailT.Perform();
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public void Work()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							this.shimForShimIAuditTrail.Work();
						}
					}
					
					
					private sealed class ShimIAuditTrailT
						: global::IAuditTrail<T>
					{
						private readonly Mock mock;
						
						public ShimIAuditTrailT(Mock @mock) =>
							this.mock = @mock;
					}
					
					private sealed class ShimIAuditTrail
						: global::IAuditTrail
					{
						private readonly Mock mock;
						
						public ShimIAuditTrail(Mock @mock) =>
							this.mock = @mock;
					}
					private global::IAuditTrailCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IAuditTrailCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::IAuditTrailCreateExpectations<T>.Adornments.AdornmentsForHandler0 Perform()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IAuditTrailCreateExpectations<T>.Handler0();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					internal global::IAuditTrailCreateExpectations<T>.Adornments.AdornmentsForHandler1 Work()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IAuditTrailCreateExpectations<T>.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					private global::IAuditTrailCreateExpectations<T> Expectations { get; }
				}
				
				internal global::IAuditTrailCreateExpectations<T>.MethodExpectations Methods { get; }
				
				public IAuditTrailCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IAuditTrail<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIAuditTrail<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIAuditTrail<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IAuditTrailCreateExpectations<T>.Handler0, global::System.Action>, IAdornmentsForIAuditTrail<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IAuditTrailCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IAuditTrailCreateExpectations<T>.Handler1, global::System.Action>, IAdornmentsForIAuditTrail<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IAuditTrailCreateExpectations<T>.Handler1 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IAuditTrailMakeExpectations<T>
			{
				internal global::IAuditTrail<T> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IAuditTrail<T>
				{
					public Mock()
					{
					}
					
					public void Perform()
					{
					}
					public void Work()
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			"""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IAuditTrailT_Rock_Create.g.cs", createGeneratedCode),
				("IAuditTrailT_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task GenerateWhenEventsExistAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: Rock(typeof(IDialogService), BuildType.Create | BuildType.Make)]

			public interface IDialogService
			{
				int ShowSuccess(string message) => message.Length;
				event EventHandler ThresholdReached;
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IDialogServiceCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<string, int>, int>
				{
					public global::Rocks.Argument<string> @message { get; set; }
				}
				private global::Rocks.Handlers<global::IDialogServiceCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IDialogServiceCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IDialogService, global::Rocks.IRaiseEvents
				{
					private readonly global::IDialogService shimForShimIDialogService;
					public Mock(global::IDialogServiceCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForShimIDialogService) = (@expectations, new ShimIDialogService(this));
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public int ShowSuccess(string @message)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@message.IsValid(@message!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@message!) : @handler.ReturnValue;
									@handler.RaiseEvents(this);
									return @result!;
								}
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(0)}
									message: {@message.FormatValue()}
								""");
						}
						else
						{
							return this.shimForShimIDialogService.ShowSuccess(@message: @message!);
						}
					}
					
					#pragma warning disable CS0067
					public event global::System.EventHandler? ThresholdReached;
					#pragma warning restore CS0067
					
					void global::Rocks.IRaiseEvents.Raise(string @fieldName, object @args)
					{
						var @thisType = this.GetType();
						var @eventDelegate = (global::System.MulticastDelegate)thisType.GetField(@fieldName, 
							global::System.Reflection.BindingFlags.Instance | global::System.Reflection.BindingFlags.NonPublic)!.GetValue(this)!;
						
						if (@eventDelegate is not null)
						{
							foreach (var @handler in @eventDelegate.GetInvocationList())
							{
								@handler.Method.Invoke(@handler.Target, new object[]{this, @args});
							}
						}
					}
					
					
					private sealed class ShimIDialogService
						: global::IDialogService
					{
						private readonly Mock mock;
						
						public ShimIDialogService(Mock @mock) =>
							this.mock = @mock;
						
						#pragma warning disable CS0067
						public event global::System.EventHandler? ThresholdReached;
						#pragma warning restore CS0067
					}
					private global::IDialogServiceCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IDialogServiceCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IDialogServiceCreateExpectations.Adornments.AdornmentsForHandler0 ShowSuccess(global::Rocks.Argument<string> @message)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@message);
						
						var @handler = new global::IDialogServiceCreateExpectations.Handler0
						{
							@message = @message,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IDialogServiceCreateExpectations Expectations { get; }
				}
				
				internal global::IDialogServiceCreateExpectations.MethodExpectations Methods { get; }
				
				public IDialogServiceCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IDialogService Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIDialogService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIDialogService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IDialogServiceCreateExpectations.Handler0, global::System.Func<string, int>, int>, IAdornmentsForIDialogService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IDialogServiceCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			internal static class IDialogServiceAdornmentsEventExtensions
			{
				internal static TAdornments RaiseThresholdReached<TAdornments>(this TAdornments self, global::System.EventArgs args) where TAdornments : global::IDialogServiceCreateExpectations.Adornments.IAdornmentsForIDialogService<TAdornments> => 
					self.AddRaiseEvent(new("ThresholdReached", args));
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IDialogServiceMakeExpectations
			{
				internal global::IDialogService Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IDialogService
				{
					public Mock()
					{
					}
					
					public int ShowSuccess(string @message)
					{
						return default!;
					}
					
					#pragma warning disable CS0067
					public event global::System.EventHandler? ThresholdReached;
					#pragma warning restore CS0067
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			"""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IDialogService_Rock_Create.g.cs", createGeneratedCode),
				("IDialogService_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task GenerateWhenDuplicatesOccurAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Linq;
			using System.Collections.Generic;

			[assembly: Rock(typeof(IRuntimeKey), BuildType.Create | BuildType.Make)]

			public interface IReadOnlyProperty 
			{ 
				Type ClrType { get; }
			}

			public interface IProperty
				: IReadOnlyProperty { }

			public interface IReadOnlyKey
			{
				bool IsPrimaryKey() => true;

				IReadOnlyList<IReadOnlyProperty> Properties { get; }
			}

			public interface IKey
				: IReadOnlyKey
			{
				Type GetKeyType() => Properties.Count > 1 ? typeof(object[]) : Properties.First().ClrType;

				new IReadOnlyList<IProperty> Properties { get; }
			}

			public interface IRuntimeKey 
				: IKey { }
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IRuntimeKeyCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::System.Type>, global::System.Type>
				{ }
				private global::Rocks.Handlers<global::IRuntimeKeyCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<bool>, bool>
				{ }
				private global::Rocks.Handlers<global::IRuntimeKeyCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IProperty>>
				{ }
				private global::Rocks.Handlers<global::IRuntimeKeyCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>
				{ }
				private global::Rocks.Handlers<global::IRuntimeKeyCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IRuntimeKeyCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IRuntimeKey
				{
					private readonly global::IKey shimForShimIKey;
					private readonly global::IReadOnlyKey shimForShimIReadOnlyKey;
					public Mock(global::IRuntimeKeyCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForShimIKey, this.shimForShimIReadOnlyKey) = (@expectations, new ShimIKey(this), new ShimIReadOnlyKey(this));
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public global::System.Type GetKeyType()
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @handler = this.Expectations.handlers0.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForShimIKey.GetKeyType();
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public bool IsPrimaryKey()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForShimIReadOnlyKey.IsPrimaryKey();
						}
					}
					
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					public global::System.Collections.Generic.IReadOnlyList<global::IProperty> Properties
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(2)}
								""");
						}
					}
					[global::Rocks.MemberIdentifier(3, global::Rocks.PropertyAccessor.Get)]
					global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> global::IReadOnlyKey.Properties
					{
						get
						{
							if (this.Expectations.handlers3 is not null)
							{
								var @handler = this.Expectations.handlers3.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(3)}
								""");
						}
					}
					
					
					private sealed class ShimIKey
						: global::IKey
					{
						private readonly Mock mock;
						
						public ShimIKey(Mock @mock) =>
							this.mock = @mock;
						
						public global::System.Collections.Generic.IReadOnlyList<global::IProperty> Properties
						{
							get => ((global::IKey)this.mock).Properties!;
						}
						
						global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> global::IReadOnlyKey.Properties
						{
							get => ((global::IKey)this.mock).Properties!;
						}
					}
					
					private sealed class ShimIReadOnlyKey
						: global::IReadOnlyKey
					{
						private readonly Mock mock;
						
						public ShimIReadOnlyKey(Mock @mock) =>
							this.mock = @mock;
						
						public global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> Properties
						{
							get => ((global::IReadOnlyKey)this.mock).Properties!;
						}
					}
					private global::IRuntimeKeyCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IRuntimeKeyCreateExpectations.Adornments.AdornmentsForHandler0 GetKeyType()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IRuntimeKeyCreateExpectations.Handler0();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					internal global::IRuntimeKeyCreateExpectations.Adornments.AdornmentsForHandler1 IsPrimaryKey()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IRuntimeKeyCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					private global::IRuntimeKeyCreateExpectations Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IRuntimeKeyCreateExpectations.Adornments.AdornmentsForHandler2 Properties()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IRuntimeKeyCreateExpectations.Handler2();
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IRuntimeKeyCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRuntimeKeyCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlyKey
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlyKey
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlyKey(global::IRuntimeKeyCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IRuntimeKeyCreateExpectations.Adornments.AdornmentsForHandler3 Properties()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IRuntimeKeyCreateExpectations.Handler3();
							if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(handler); }
							else { this.Expectations.handlers3.Add(handler); }
							return new(handler);
						}
						private global::IRuntimeKeyCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlyKey(global::IRuntimeKeyCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRuntimeKeyCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyKey.ExplicitPropertyGetterExpectationsForIReadOnlyKey Getters { get; }
				}
				
				internal global::IRuntimeKeyCreateExpectations.MethodExpectations Methods { get; }
				internal global::IRuntimeKeyCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IRuntimeKeyCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyKey ExplicitPropertiesForIReadOnlyKey { get; }
				
				public IRuntimeKeyCreateExpectations() =>
					(this.Methods, this.Properties, this.ExplicitPropertiesForIReadOnlyKey) = (new(this), new(this), new(this));
				
				internal global::IRuntimeKey Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIRuntimeKey<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIRuntimeKey<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IRuntimeKeyCreateExpectations.Handler0, global::System.Func<global::System.Type>, global::System.Type>, IAdornmentsForIRuntimeKey<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IRuntimeKeyCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IRuntimeKeyCreateExpectations.Handler1, global::System.Func<bool>, bool>, IAdornmentsForIRuntimeKey<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IRuntimeKeyCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IRuntimeKeyCreateExpectations.Handler2, global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IProperty>>, IAdornmentsForIRuntimeKey<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IRuntimeKeyCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::IRuntimeKeyCreateExpectations.Handler3, global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>, IAdornmentsForIRuntimeKey<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::IRuntimeKeyCreateExpectations.Handler3 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IRuntimeKeyMakeExpectations
			{
				internal global::IRuntimeKey Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IRuntimeKey
				{
					public Mock()
					{
					}
					
					public global::System.Type GetKeyType()
					{
						return default!;
					}
					public bool IsPrimaryKey()
					{
						return default!;
					}
					public global::System.Collections.Generic.IReadOnlyList<global::IProperty> Properties
					{
						get => default!;
					}
					global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> global::IReadOnlyKey.Properties
					{
						get => default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IRuntimeKey_Rock_Create.g.cs", createGeneratedCode),
				("IRuntimeKey_Rock_Make.g.cs", makeGeneratedCode)        
			],
			[]);
	}

	[Test]
	public static async Task GenerateAbstractCreateAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: Rock(typeof(IHaveDims), BuildType.Create | BuildType.Make)]

			public interface IDoNotHaveDims
			{
				int IAmNotADim();
				int NotDim { get; }
				int this[string notDimKey] { get; }
			}
			
			public interface IHaveDims
				: IDoNotHaveDims
			{
				int IAmADim() => 2;
				int AmADim { get => 2; }
				int this[string dimKey, int dimValue] { get => dimKey.GetHashCode() + dimValue; }
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IHaveDimsCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Func<string, int, int>, int>
				{
					public global::Rocks.Argument<string> @dimKey { get; set; }
					public global::Rocks.Argument<int> @dimValue { get; set; }
				}
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler3>? @handlers3;
				internal sealed class Handler4
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler4>? @handlers4;
				internal sealed class Handler5
					: global::Rocks.Handler<global::System.Func<string, int>, int>
				{
					public global::Rocks.Argument<string> @notDimKey { get; set; }
				}
				private global::Rocks.Handlers<global::IHaveDimsCreateExpectations.Handler5>? @handlers5;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IHaveDimsCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
						if (this.handlers4 is not null) { failures.AddRange(this.Verify(this.handlers4, 4)); }
						if (this.handlers5 is not null) { failures.AddRange(this.Verify(this.handlers5, 5)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveDims
				{
					private readonly global::IHaveDims shimForShimIHaveDims;
					public Mock(global::IHaveDimsCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForShimIHaveDims) = (@expectations, new ShimIHaveDims(this));
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public int IAmADim()
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @handler = this.Expectations.handlers0.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForShimIHaveDims.IAmADim();
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public int IAmNotADim()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						
						this.Expectations.WasExceptionThrown = true;
						throw new global::Rocks.Exceptions.ExpectationException(
							$"""
							No handlers were found for {this.GetType().GetMemberDescription(1)}
							""");
					}
					
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					public int AmADim
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							else
							{
								return this.shimForShimIHaveDims.AmADim;
							}
						}
					}
					[global::Rocks.MemberIdentifier(4, global::Rocks.PropertyAccessor.Get)]
					public int NotDim
					{
						get
						{
							if (this.Expectations.handlers4 is not null)
							{
								var @handler = this.Expectations.handlers4.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(4)}
								""");
						}
					}
					
					[global::Rocks.MemberIdentifier(3, global::Rocks.PropertyAccessor.Get)]
					public int this[string @dimKey, int @dimValue]
					{
						get
						{
							if (this.Expectations.handlers3 is not null)
							{
								foreach (var @handler in this.Expectations.handlers3)
								{
									if (@handler.@dimKey.IsValid(@dimKey!) &&
										@handler.@dimValue.IsValid(@dimValue!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@dimKey!, @dimValue!) : @handler.ReturnValue;
										return @result!;
									}
								}
								
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									No handlers match for {this.GetType().GetMemberDescription(3)}
										dimKey: {@dimKey.FormatValue()}
										dimValue: {@dimValue.FormatValue()}
									""");
							}
							else
							{
								return this.shimForShimIHaveDims[@dimKey: @dimKey!, @dimValue: @dimValue!];
							}
						}
					}
					[global::Rocks.MemberIdentifier(5, global::Rocks.PropertyAccessor.Get)]
					public int this[string @notDimKey]
					{
						get
						{
							if (this.Expectations.handlers5 is not null)
							{
								foreach (var @handler in this.Expectations.handlers5)
								{
									if (@handler.@notDimKey.IsValid(@notDimKey!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@notDimKey!) : @handler.ReturnValue;
										return @result!;
									}
								}
								
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									No handlers match for {this.GetType().GetMemberDescription(5)}
										notDimKey: {@notDimKey.FormatValue()}
									""");
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers were found for {this.GetType().GetMemberDescription(5)}
									notDimKey: {@notDimKey.FormatValue()}
								""");
						}
					}
					
					
					private sealed class ShimIHaveDims
						: global::IHaveDims
					{
						private readonly Mock mock;
						
						public ShimIHaveDims(Mock @mock) =>
							this.mock = @mock;
						
						public int IAmNotADim() =>
							((global::IHaveDims)this.mock).IAmNotADim()!;
						
						public int NotDim
						{
							get => ((global::IHaveDims)this.mock).NotDim!;
						}
						
						public int this[string @notDimKey]
						{
							get => ((global::IHaveDims)this.mock)[@notDimKey]!;
						}
					}
					private global::IHaveDimsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveDimsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler0 IAmADim()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHaveDimsCreateExpectations.Handler0();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler1 IAmNotADim()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHaveDimsCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					private global::IHaveDimsCreateExpectations Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IHaveDimsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler2 AmADim()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IHaveDimsCreateExpectations.Handler2();
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler4 NotDim()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IHaveDimsCreateExpectations.Handler4();
							if (this.Expectations.handlers4 is null) { this.Expectations.handlers4 = new(handler); }
							else { this.Expectations.handlers4.Add(handler); }
							return new(handler);
						}
						private global::IHaveDimsCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IHaveDimsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveDimsCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IHaveDimsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler3 This(global::Rocks.Argument<string> @dimKey, global::Rocks.Argument<int> @dimValue)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@dimKey);
							global::System.ArgumentNullException.ThrowIfNull(@dimValue);
							
							var @handler = new global::IHaveDimsCreateExpectations.Handler3
							{
								@dimKey = @dimKey,
								@dimValue = @dimValue,
							};
							
							if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(@handler); }
							else { this.Expectations.handlers3.Add(@handler); }
							return new(@handler);
						}
						internal global::IHaveDimsCreateExpectations.Adornments.AdornmentsForHandler5 This(global::Rocks.Argument<string> @notDimKey)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@notDimKey);
							
							var @handler = new global::IHaveDimsCreateExpectations.Handler5
							{
								@notDimKey = @notDimKey,
							};
							
							if (this.Expectations.handlers5 is null) { this.Expectations.handlers5 = new(@handler); }
							else { this.Expectations.handlers5.Add(@handler); }
							return new(@handler);
						}
						private global::IHaveDimsCreateExpectations Expectations { get; }
					}
					
					
					internal IndexerExpectations(global::IHaveDimsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveDimsCreateExpectations.IndexerExpectations.IndexerGetterExpectations Getters { get; }
				}
				
				internal global::IHaveDimsCreateExpectations.MethodExpectations Methods { get; }
				internal global::IHaveDimsCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IHaveDimsCreateExpectations.IndexerExpectations Indexers { get; }
				
				public IHaveDimsCreateExpectations() =>
					(this.Methods, this.Properties, this.Indexers) = (new(this), new(this), new(this));
				
				internal global::IHaveDims Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHaveDims<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHaveDims<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHaveDimsCreateExpectations.Handler0, global::System.Func<int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHaveDimsCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IHaveDimsCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IHaveDimsCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IHaveDimsCreateExpectations.Handler2, global::System.Func<int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IHaveDimsCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler4
						: global::Rocks.Adornments<AdornmentsForHandler4, global::IHaveDimsCreateExpectations.Handler4, global::System.Func<int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler4>
					{
						public AdornmentsForHandler4(global::IHaveDimsCreateExpectations.Handler4 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::IHaveDimsCreateExpectations.Handler3, global::System.Func<string, int, int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::IHaveDimsCreateExpectations.Handler3 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler5
						: global::Rocks.Adornments<AdornmentsForHandler5, global::IHaveDimsCreateExpectations.Handler5, global::System.Func<string, int>, int>, IAdornmentsForIHaveDims<AdornmentsForHandler5>
					{
						public AdornmentsForHandler5(global::IHaveDimsCreateExpectations.Handler5 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IHaveDimsMakeExpectations
			{
				internal global::IHaveDims Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IHaveDims
				{
					public Mock()
					{
					}
					
					public int IAmADim()
					{
						return default!;
					}
					public int IAmNotADim()
					{
						return default!;
					}
					public int AmADim
					{
						get => default!;
					}
					public int NotDim
					{
						get => default!;
					}
					public int this[string @dimKey, int @dimValue]
					{
						get => default!;
					}
					public int this[string @notDimKey]
					{
						get => default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IHaveDims_Rock_Create.g.cs", createGeneratedCode),
				("IHaveDims_Rock_Make.g.cs", makeGeneratedCode)       
			],
			[]);
	}
}