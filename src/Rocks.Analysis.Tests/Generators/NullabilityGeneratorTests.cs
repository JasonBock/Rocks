using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Testing;
using NUnit.Framework;

namespace Rocks.Analysis.Tests.Generators;

public static class NullabilityGeneratorTests
{
	[Test]
	public static async Task GenerateWithAllowNullParameterAndDefaultValueAsync()
	{
		var code =
			"""
			using Rocks;
			using System.Diagnostics.CodeAnalysis;

			[assembly: Rock(typeof(ConnectionBuilder<>), BuildType.Create | BuildType.Make)]

			#nullable enable

			public interface IGraphType { }

			public class ConnectionBuilder<TSourceType>
			{
				public virtual ConnectionBuilder<TSourceType> Argument<TArgumentGraphType, TArgumentType>(string name, string? description,
					[AllowNull] TArgumentType defaultValue = default!)
						where TArgumentGraphType : IGraphType => new();
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class ConnectionBuilderCreateExpectations<TSourceType>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::ConnectionBuilderCreateExpectations<TSourceType>.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::ConnectionBuilderCreateExpectations<TSourceType>.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::ConnectionBuilderCreateExpectations<TSourceType>.Handler2>? @handlers2;
				internal sealed class Handler3<TArgumentGraphType, TArgumentType>
					: global::Rocks.Handler<global::System.Func<string, string?, TArgumentType, global::ConnectionBuilder<TSourceType>>, global::ConnectionBuilder<TSourceType>>
					where TArgumentGraphType : global::IGraphType
				{
					public global::Rocks.Argument<string> @name { get; set; }
					public global::Rocks.Argument<string?> @description { get; set; }
					public global::Rocks.Argument<TArgumentType> @defaultValue { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers3;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::ConnectionBuilderCreateExpectations<TSourceType> was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::ConnectionBuilder<TSourceType>
				{
					public Mock(global::ConnectionBuilderCreateExpectations<TSourceType> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(0)}
									obj: {@obj.FormatValue()}
								""");
						}
						else
						{
							return base.Equals(@obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3)]
					public override global::ConnectionBuilder<TSourceType> Argument<TArgumentGraphType, TArgumentType>(string @name, string? @description, [global::System.Diagnostics.CodeAnalysis.AllowNullAttribute] TArgumentType @defaultValue = default!)
					{
						if (this.Expectations.handlers3 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers3)
							{
								if (@genericHandler is global::ConnectionBuilderCreateExpectations<TSourceType>.Handler3<TArgumentGraphType, TArgumentType> @handler)
								{
									if (@handler.@name.IsValid(@name!) &&
										@handler.@description.IsValid(@description!) &&
										@handler.@defaultValue.IsValid(@defaultValue!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@name!, @description!, @defaultValue!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(3)}
									name: {@name.FormatValue()}
									description: {@description.FormatValue()}
									defaultValue: {@defaultValue.FormatValue()}
								""");
						}
						else
						{
							return base.Argument<TArgumentGraphType, TArgumentType>(@name: @name!, @description: @description!, @defaultValue: @defaultValue!);
						}
					}
					
					private global::ConnectionBuilderCreateExpectations<TSourceType> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::ConnectionBuilderCreateExpectations<TSourceType> expectations) =>
						this.Expectations = expectations;
					
					internal global::ConnectionBuilderCreateExpectations<TSourceType>.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::ConnectionBuilderCreateExpectations<TSourceType>.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::ConnectionBuilderCreateExpectations<TSourceType>.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::ConnectionBuilderCreateExpectations<TSourceType>.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::ConnectionBuilderCreateExpectations<TSourceType>.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::ConnectionBuilderCreateExpectations<TSourceType>.Handler2();
						if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::ConnectionBuilderCreateExpectations<TSourceType>.Adornments.AdornmentsForHandler3<TArgumentGraphType, TArgumentType> Argument<TArgumentGraphType, TArgumentType>(global::Rocks.Argument<string> @name, global::Rocks.Argument<string?> @description, global::Rocks.Argument<TArgumentType> @defaultValue) where TArgumentGraphType : global::IGraphType
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@name);
						global::System.ArgumentNullException.ThrowIfNull(@description);
						global::System.ArgumentNullException.ThrowIfNull(@defaultValue);
						
						var @handler = new global::ConnectionBuilderCreateExpectations<TSourceType>.Handler3<TArgumentGraphType, TArgumentType>
						{
							@name = @name,
							@description = @description,
							@defaultValue = @defaultValue.Transform(default!),
						};
						
						if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(@handler); }
						else { this.Expectations.handlers3.Add(@handler); }
						return new(@handler);
					}
					internal global::ConnectionBuilderCreateExpectations<TSourceType>.Adornments.AdornmentsForHandler3<TArgumentGraphType, TArgumentType> Argument<TArgumentGraphType, TArgumentType>(global::Rocks.Argument<string> @name, global::Rocks.Argument<string?> @description, TArgumentType @defaultValue = default!) where TArgumentGraphType : global::IGraphType =>
						this.Argument<TArgumentGraphType, TArgumentType>(@name, @description, global::Rocks.Arg.Is(@defaultValue));
					
					private global::ConnectionBuilderCreateExpectations<TSourceType> Expectations { get; }
				}
				
				internal global::ConnectionBuilderCreateExpectations<TSourceType>.MethodExpectations Methods { get; }
				
				public ConnectionBuilderCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::ConnectionBuilder<TSourceType> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForConnectionBuilder<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForConnectionBuilder<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::ConnectionBuilderCreateExpectations<TSourceType>.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForConnectionBuilder<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::ConnectionBuilderCreateExpectations<TSourceType>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::ConnectionBuilderCreateExpectations<TSourceType>.Handler1, global::System.Func<int>, int>, IAdornmentsForConnectionBuilder<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::ConnectionBuilderCreateExpectations<TSourceType>.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::ConnectionBuilderCreateExpectations<TSourceType>.Handler2, global::System.Func<string?>, string?>, IAdornmentsForConnectionBuilder<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::ConnectionBuilderCreateExpectations<TSourceType>.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3<TArgumentGraphType, TArgumentType>
						: global::Rocks.Adornments<AdornmentsForHandler3<TArgumentGraphType, TArgumentType>, global::ConnectionBuilderCreateExpectations<TSourceType>.Handler3<TArgumentGraphType, TArgumentType>, global::System.Func<string, string?, TArgumentType, global::ConnectionBuilder<TSourceType>>, global::ConnectionBuilder<TSourceType>>, IAdornmentsForConnectionBuilder<AdornmentsForHandler3<TArgumentGraphType, TArgumentType>> where TArgumentGraphType : global::IGraphType
					{
						public AdornmentsForHandler3(global::ConnectionBuilderCreateExpectations<TSourceType>.Handler3<TArgumentGraphType, TArgumentType> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class ConnectionBuilderMakeExpectations<TSourceType>
			{
				internal global::ConnectionBuilder<TSourceType> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::ConnectionBuilder<TSourceType>
				{
					public Mock()
					{
					}
					
					public override bool Equals(object? @obj)
					{
						return default!;
					}
					public override int GetHashCode()
					{
						return default!;
					}
					public override string? ToString()
					{
						return default!;
					}
					public override global::ConnectionBuilder<TSourceType> Argument<TArgumentGraphType, TArgumentType>(string @name, string? @description, [global::System.Diagnostics.CodeAnalysis.AllowNullAttribute] TArgumentType @defaultValue = default!)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("ConnectionBuilderTSourceType_Rock_Create.g.cs", createGeneratedCode),
				("ConnectionBuilderTSourceType_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task GenerateWhenNullabilityChangesInOverrideAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: Rock(typeof(SubTracer), BuildType.Create | BuildType.Make)]

			#nullable enable

			public class Tracer
			{
				public virtual void TraceEvent(string? eventCache, string source, 
					string eventType, int id, 
					string? format, params object?[]? args)
				{ }
			}

			public class SubTracer
				: Tracer
			{
				public override void TraceEvent(string eventCache, string source, 
					string eventType, int id, 
					string format, params object[] args)
				{ }
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class SubTracerCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler4
					: global::Rocks.Handler<global::System.Action<string, string, string, int, string, object[]>>
				{
					public global::Rocks.Argument<string> @eventCache { get; set; }
					public global::Rocks.Argument<string> @source { get; set; }
					public global::Rocks.Argument<string> @eventType { get; set; }
					public global::Rocks.Argument<int> @id { get; set; }
					public global::Rocks.Argument<string> @format { get; set; }
					public global::Rocks.Argument<object[]> @args { get; set; }
				}
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler4>? @handlers4;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::SubTracerCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers4 is not null) { failures.AddRange(this.Verify(this.handlers4, 4)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::SubTracer
				{
					public Mock(global::SubTracerCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(0)}
									obj: {@obj.FormatValue()}
								""");
						}
						else
						{
							return base.Equals(@obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(4)]
					public override void TraceEvent(string @eventCache, string @source, string @eventType, int @id, string @format, params object[] @args)
					{
						if (this.Expectations.handlers4 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers4)
							{
								if (@handler.@eventCache.IsValid(@eventCache!) &&
									@handler.@source.IsValid(@source!) &&
									@handler.@eventType.IsValid(@eventType!) &&
									@handler.@id.IsValid(@id!) &&
									@handler.@format.IsValid(@format!) &&
									@handler.@args.IsValid(@args!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@eventCache!, @source!, @eventType!, @id!, @format!, @args!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									No handlers match for {this.GetType().GetMemberDescription(4)}
										eventCache: {@eventCache.FormatValue()}
										source: {@source.FormatValue()}
										eventType: {@eventType.FormatValue()}
										id: {@id.FormatValue()}
										format: {@format.FormatValue()}
										args: {@args.FormatValue()}
									""");
							}
						}
						else
						{
							base.TraceEvent(@eventCache: @eventCache!, @source: @source!, @eventType: @eventType!, @id: @id!, @format: @format!, @args: @args!);
						}
					}
					
					private global::SubTracerCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::SubTracerCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::SubTracerCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::SubTracerCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::SubTracerCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler4 TraceEvent(global::Rocks.Argument<string> @eventCache, global::Rocks.Argument<string> @source, global::Rocks.Argument<string> @eventType, global::Rocks.Argument<int> @id, global::Rocks.Argument<string> @format, global::Rocks.Argument<object[]> @args)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@eventCache);
						global::System.ArgumentNullException.ThrowIfNull(@source);
						global::System.ArgumentNullException.ThrowIfNull(@eventType);
						global::System.ArgumentNullException.ThrowIfNull(@id);
						global::System.ArgumentNullException.ThrowIfNull(@format);
						global::System.ArgumentNullException.ThrowIfNull(@args);
						
						var @handler = new global::SubTracerCreateExpectations.Handler4
						{
							@eventCache = @eventCache,
							@source = @source,
							@eventType = @eventType,
							@id = @id,
							@format = @format,
							@args = @args,
						};
						
						if (this.Expectations.handlers4 is null) { this.Expectations.handlers4 = new(@handler); }
						else { this.Expectations.handlers4.Add(@handler); }
						return new(@handler);
					}
					
					private global::SubTracerCreateExpectations Expectations { get; }
				}
				
				internal global::SubTracerCreateExpectations.MethodExpectations Methods { get; }
				
				public SubTracerCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::SubTracer Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForSubTracer<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForSubTracer<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::SubTracerCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForSubTracer<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::SubTracerCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::SubTracerCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForSubTracer<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::SubTracerCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::SubTracerCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForSubTracer<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::SubTracerCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler4
						: global::Rocks.Adornments<AdornmentsForHandler4, global::SubTracerCreateExpectations.Handler4, global::System.Action<string, string, string, int, string, object[]>>, IAdornmentsForSubTracer<AdornmentsForHandler4>
					{
						public AdornmentsForHandler4(global::SubTracerCreateExpectations.Handler4 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class SubTracerMakeExpectations
			{
				internal global::SubTracer Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::SubTracer
				{
					public Mock()
					{
					}
					
					public override bool Equals(object? @obj)
					{
						return default!;
					}
					public override int GetHashCode()
					{
						return default!;
					}
					public override string? ToString()
					{
						return default!;
					}
					public override void TraceEvent(string @eventCache, string @source, string @eventType, int @id, string @format, params object[] @args)
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		// The two diagnostic IDs are actually warnings, so they
		// can be ignored/suppressed. They show up because the override
		// continues the problem that the subtype introduces when it changes
		// the nullability annotations.
		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("SubTracer_Rock_Create.g.cs", createGeneratedCode),
				("SubTracer_Rock_Make.g.cs", makeGeneratedCode)
			],
			[
				new DiagnosticResult("CS8610", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("args"),
				new DiagnosticResult("CS8765", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("eventCache"),
				new DiagnosticResult("CS8765", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("format"),
			]);
	}

	[Test]
	public static async Task GenerateWhenPropertyInShimNeedsNullForgivingAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: Rock(typeof(IConventionSkipNavigation), BuildType.Create | BuildType.Make)]

			#nullable enable

			public interface IReadOnlyNavigationBase
			{
				IReadOnlyNavigationBase? Inverse { get; }
			}

			public interface IReadOnlySkipNavigation
				: IReadOnlyNavigationBase
			{
				new IReadOnlySkipNavigation Inverse { get; }

				IReadOnlyNavigationBase IReadOnlyNavigationBase.Inverse
				{
					get => Inverse;
				}
			}

			public interface IConventionSkipNavigation 
				: IReadOnlySkipNavigation
			{
				new IConventionSkipNavigation? Inverse
				{
					get => (IConventionSkipNavigation?)((IReadOnlySkipNavigation)this).Inverse;
				}
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IConventionSkipNavigationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::IConventionSkipNavigation?>, global::IConventionSkipNavigation?>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<global::IReadOnlySkipNavigation>, global::IReadOnlySkipNavigation>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::IReadOnlyNavigationBase?>, global::IReadOnlyNavigationBase?>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler2>? @handlers2;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IConventionSkipNavigationCreateExpectations was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IConventionSkipNavigation
				{
					private readonly global::IConventionSkipNavigation shimForShimIConventionSkipNavigation;
					public Mock(global::IConventionSkipNavigationCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForShimIConventionSkipNavigation) = (@expectations, new ShimIConventionSkipNavigation(this));
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public global::IConventionSkipNavigation? Inverse
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							else
							{
								return this.shimForShimIConventionSkipNavigation.Inverse;
							}
						}
					}
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Get)]
					global::IReadOnlySkipNavigation global::IReadOnlySkipNavigation.Inverse
					{
						get
						{
							if (this.Expectations.handlers1 is not null)
							{
								var @handler = this.Expectations.handlers1.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(1)}
								""");
						}
					}
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					global::IReadOnlyNavigationBase? global::IReadOnlyNavigationBase.Inverse
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers match for {this.GetType().GetMemberDescription(2)}
								""");
						}
					}
					
					
					private sealed class ShimIConventionSkipNavigation
						: global::IConventionSkipNavigation
					{
						private readonly Mock mock;
						
						public ShimIConventionSkipNavigation(Mock @mock) =>
							this.mock = @mock;
						
						global::IReadOnlySkipNavigation global::IReadOnlySkipNavigation.Inverse
						{
							get => ((global::IReadOnlySkipNavigation)this.mock).Inverse!;
						}
						
						global::IReadOnlyNavigationBase? global::IReadOnlyNavigationBase.Inverse
						{
							get => ((global::IReadOnlyNavigationBase)this.mock).Inverse!;
						}
					}
					private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler0 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlySkipNavigation
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler1 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler1();
							if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
							else { this.Expectations.handlers1.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlySkipNavigation(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlySkipNavigation.ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlyNavigationBase
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler2 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler2();
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlyNavigationBase(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyNavigationBase.ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase Getters { get; }
				}
				
				internal global::IConventionSkipNavigationCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlySkipNavigation ExplicitPropertiesForIReadOnlySkipNavigation { get; }
				internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyNavigationBase ExplicitPropertiesForIReadOnlyNavigationBase { get; }
				
				public IConventionSkipNavigationCreateExpectations() =>
					(this.Properties, this.ExplicitPropertiesForIReadOnlySkipNavigation, this.ExplicitPropertiesForIReadOnlyNavigationBase) = (new(this), new(this), new(this));
				
				internal global::IConventionSkipNavigation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIConventionSkipNavigation<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIConventionSkipNavigation<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IConventionSkipNavigationCreateExpectations.Handler0, global::System.Func<global::IConventionSkipNavigation?>, global::IConventionSkipNavigation?>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IConventionSkipNavigationCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IConventionSkipNavigationCreateExpectations.Handler1, global::System.Func<global::IReadOnlySkipNavigation>, global::IReadOnlySkipNavigation>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IConventionSkipNavigationCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IConventionSkipNavigationCreateExpectations.Handler2, global::System.Func<global::IReadOnlyNavigationBase?>, global::IReadOnlyNavigationBase?>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IConventionSkipNavigationCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IConventionSkipNavigationMakeExpectations
			{
				internal global::IConventionSkipNavigation Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IConventionSkipNavigation
				{
					public Mock()
					{
					}
					
					public global::IConventionSkipNavigation? Inverse
					{
						get => default!;
					}
					global::IReadOnlySkipNavigation global::IReadOnlySkipNavigation.Inverse
					{
						get => default!;
					}
					global::IReadOnlyNavigationBase? global::IReadOnlyNavigationBase.Inverse
					{
						get => default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IConventionSkipNavigation_Rock_Create.g.cs", createGeneratedCode),
				("IConventionSkipNavigation_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task GenerateWhenTargetIsInterfaceAndMethodIsConstrainedByTypeParameterThatIsAssignedAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: Rock(typeof(IDestination<>), BuildType.Create | BuildType.Make)]

			public interface IDestination<TDestination>
			{
				void As<T>() where T : TDestination;
			}
			""";

		var createGeneratedCode =
			""""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IDestinationCreateExpectations<TDestination>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0<T>
					: global::Rocks.Handler<global::System.Action>
					where T : notnull, TDestination
				{ }
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
				
				public override void Verify()
				{
					if (!this.WasInstanceInvoked)
					{
						throw new global::Rocks.Exceptions.VerificationException([$"An instance of global::IDestinationCreateExpectations<TDestination> was never made."]);
					}
					else if (!this.WasExceptionThrown)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IDestination<TDestination>
				{
					public Mock(global::IDestinationCreateExpectations<TDestination> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void As<T>()
						where T : notnull, TDestination
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @genericHandler = this.Expectations.handlers0.First;
							if (@genericHandler is global::IDestinationCreateExpectations<TDestination>.Handler0<T> @handler)
							{
								@handler.CallCount++;
								@handler.Callback?.Invoke();
							}
							else
							{
								this.Expectations.WasExceptionThrown = true;
								throw new global::Rocks.Exceptions.ExpectationException(
									$"""
									The provided handler does not match for {this.GetType().GetMemberDescription(0)}
									""");
							}
						}
						else
						{
							this.Expectations.WasExceptionThrown = true;
							throw new global::Rocks.Exceptions.ExpectationException(
								$"""
								No handlers were found for {this.GetType().GetMemberDescription(0)}
								""");
						}
					}
					
					private global::IDestinationCreateExpectations<TDestination> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IDestinationCreateExpectations<TDestination> expectations) =>
						this.Expectations = expectations;
					
					internal global::IDestinationCreateExpectations<TDestination>.Adornments.AdornmentsForHandler0<T> As<T>() where T : notnull, TDestination
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IDestinationCreateExpectations<TDestination>.Handler0<T>();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					private global::IDestinationCreateExpectations<TDestination> Expectations { get; }
				}
				
				internal global::IDestinationCreateExpectations<TDestination>.MethodExpectations Methods { get; }
				
				public IDestinationCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IDestination<TDestination> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIDestination<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIDestination<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0<T>
						: global::Rocks.Adornments<AdornmentsForHandler0<T>, global::IDestinationCreateExpectations<TDestination>.Handler0<T>, global::System.Action>, IAdornmentsForIDestination<AdornmentsForHandler0<T>> where T : notnull, TDestination
					{
						public AdornmentsForHandler0(global::IDestinationCreateExpectations<TDestination>.Handler0<T> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			"""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IDestinationMakeExpectations<TDestination>
			{
				internal global::IDestination<TDestination> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IDestination<TDestination>
				{
					public Mock()
					{
					}
					
					public void As<T>()
						where T : notnull, TDestination
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				("IDestinationTDestination_Rock_Create.g.cs", createGeneratedCode),
				("IDestinationTDestination_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}
}