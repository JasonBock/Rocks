using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class ShimBuilderGeneratorTests
{
	[Test]
	public static async Task CreateWhenDuplicatesOccurAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Linq;
			using System.Collections.Generic;

			[assembly: RockCreate<IRuntimeKey>]

			public interface IReadOnlyProperty 
			{ 
				Type ClrType { get; }
			}

			public interface IProperty
				: IReadOnlyProperty { }

			public interface IReadOnlyKey
			{
				bool IsPrimaryKey() => true;

				IReadOnlyList<IReadOnlyProperty> Properties { get; }
			}

			public interface IKey
				: IReadOnlyKey
			{
				Type GetKeyType() => Properties.Count > 1 ? typeof(object[]) : Properties.First().ClrType;

				new IReadOnlyList<IProperty> Properties { get; }
			}

			public interface IRuntimeKey 
				: IKey { }
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IRuntimeKeyCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::System.Type>, global::System.Type>
				{ }
				
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<bool>, bool>
				{ }
				
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IProperty>>
				{ }
				
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>
				{ }
				
				private global::System.Collections.Generic.List<global::IRuntimeKeyCreateExpectations.Handler0>? @handlers0;
				private global::System.Collections.Generic.List<global::IRuntimeKeyCreateExpectations.Handler1>? @handlers1;
				private global::System.Collections.Generic.List<global::IRuntimeKeyCreateExpectations.Handler2>? @handlers2;
				private global::System.Collections.Generic.List<global::IRuntimeKeyCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1?.Count > 0) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2?.Count > 0) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3?.Count > 0) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IRuntimeKey
				{
					private readonly global::IKey shimForIKey;
					private readonly global::IReadOnlyKey shimForIReadOnlyKey;
					public Mock(global::IRuntimeKeyCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForIKey, this.shimForIReadOnlyKey) = (@expectations, new ShimIKey(this), new ShimIReadOnlyKey(this));
					}
					
					[global::Rocks.MemberIdentifier(0, "global::System.Type GetKeyType()")]
					public global::System.Type GetKeyType()
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							var @handler = this.Expectations.handlers0[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForIKey.GetKeyType();
						}
					}
					
					[global::Rocks.MemberIdentifier(1, "bool IsPrimaryKey()")]
					public bool IsPrimaryKey()
					{
						if (this.Expectations.handlers1?.Count > 0)
						{
							var @handler = this.Expectations.handlers1[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForIReadOnlyKey.IsPrimaryKey();
						}
					}
					
					[global::Rocks.MemberIdentifier(2, "get_Properties()")]
					public global::System.Collections.Generic.IReadOnlyList<global::IProperty> Properties
					{
						get
						{
							if (this.Expectations.handlers2?.Count > 0)
							{
								var @handler = this.Expectations.handlers2[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for get_Properties())");
						}
					}
					[global::Rocks.MemberIdentifier(3, "global::IReadOnlyKey.get_Properties()")]
					global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> global::IReadOnlyKey.Properties
					{
						get
						{
							if (this.Expectations.handlers3?.Count > 0)
							{
								var @handler = this.Expectations.handlers3[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for global::IReadOnlyKey.get_Properties())");
						}
					}
					
					
					private sealed class ShimIKey
						: global::IKey
					{
						private readonly Mock mock;
						
						public ShimIKey(Mock @mock) =>
							this.mock = @mock;
						
						public global::System.Collections.Generic.IReadOnlyList<global::IProperty> Properties
						{
							get => ((global::IKey)this.mock).Properties!;
						}
						
						global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> global::IReadOnlyKey.Properties
						{
							get => ((global::IKey)this.mock).Properties!;
						}
					}
					
					private sealed class ShimIReadOnlyKey
						: global::IReadOnlyKey
					{
						private readonly Mock mock;
						
						public ShimIReadOnlyKey(Mock @mock) =>
							this.mock = @mock;
						
						public global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty> Properties
						{
							get => ((global::IReadOnlyKey)this.mock).Properties!;
						}
					}
					private global::IRuntimeKeyCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IRuntimeKeyCreateExpectations.Handler0, global::System.Func<global::System.Type>, global::System.Type> GetKeyType()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						var handler = new global::IRuntimeKeyCreateExpectations.Handler0();
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					internal global::Rocks.Adornments<global::IRuntimeKeyCreateExpectations.Handler1, global::System.Func<bool>, bool> IsPrimaryKey()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(); }
						var handler = new global::IRuntimeKeyCreateExpectations.Handler1();
						this.Expectations.handlers1.Add(handler);
						return new(handler);
					}
					
					private global::IRuntimeKeyCreateExpectations Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IRuntimeKeyCreateExpectations.Handler2, global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IProperty>> Properties()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(); }
							var handler = new global::IRuntimeKeyCreateExpectations.Handler2();
							this.Expectations.handlers2.Add(handler);
							return new(handler);
						}
						private global::IRuntimeKeyCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IRuntimeKeyCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRuntimeKeyCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlyKey
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlyKey
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlyKey(global::IRuntimeKeyCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IRuntimeKeyCreateExpectations.Handler3, global::System.Func<global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>>, global::System.Collections.Generic.IReadOnlyList<global::IReadOnlyProperty>> Properties()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(); }
							var handler = new global::IRuntimeKeyCreateExpectations.Handler3();
							this.Expectations.handlers3.Add(handler);
							return new(handler);
						}
						private global::IRuntimeKeyCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlyKey(global::IRuntimeKeyCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRuntimeKeyCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyKey.ExplicitPropertyGetterExpectationsForIReadOnlyKey Getters { get; }
				}
				
				internal global::IRuntimeKeyCreateExpectations.MethodExpectations Methods { get; }
				internal global::IRuntimeKeyCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IRuntimeKeyCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyKey ExplicitPropertiesForIReadOnlyKey { get; }
				
				internal IRuntimeKeyCreateExpectations() =>
					(this.Methods, this.Properties, this.ExplicitPropertiesForIReadOnlyKey) = (new(this), new(this), new(this));
				
				internal global::IRuntimeKey Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IRuntimeKey_Rock_Create.g.cs", generatedCode) },
			[]);
	}

	[Test]
	public static async Task GenerateAbstractCreateAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<IHaveDims>]

			public interface IDoNotHaveDims
			{
				int IAmNotADim();
				int NotDim { get; }
				int this[string notDimKey] { get; }
			}
			
			public interface IHaveDims
				: IDoNotHaveDims
			{
				int IAmADim() => 2;
				int AmADim { get => 2; }
				int this[string dimKey, int dimValue] { get => dimKey.GetHashCode() + dimValue; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IHaveDimsCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Func<string, int, int>, int>
				{
					public global::Rocks.Argument<string> @dimKey { get; set; }
					public global::Rocks.Argument<int> @dimValue { get; set; }
				}
				
				internal sealed class Handler4
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler5
					: global::Rocks.Handler<global::System.Func<string, int>, int>
				{
					public global::Rocks.Argument<string> @notDimKey { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler0>? @handlers0;
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler1>? @handlers1;
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler2>? @handlers2;
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler3>? @handlers3;
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler4>? @handlers4;
				private global::System.Collections.Generic.List<global::IHaveDimsCreateExpectations.Handler5>? @handlers5;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1?.Count > 0) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2?.Count > 0) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3?.Count > 0) { failures.AddRange(this.Verify(this.handlers3, 3)); }
						if (this.handlers4?.Count > 0) { failures.AddRange(this.Verify(this.handlers4, 4)); }
						if (this.handlers5?.Count > 0) { failures.AddRange(this.Verify(this.handlers5, 5)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveDims
				{
					private readonly global::IHaveDims shimForIHaveDims;
					public Mock(global::IHaveDimsCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForIHaveDims) = (@expectations, new ShimIHaveDims(this));
					}
					
					[global::Rocks.MemberIdentifier(0, "int IAmADim()")]
					public int IAmADim()
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							var @handler = this.Expectations.handlers0[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return this.shimForIHaveDims.IAmADim();
						}
					}
					
					[global::Rocks.MemberIdentifier(1, "int IAmNotADim()")]
					public int IAmNotADim()
					{
						if (this.Expectations.handlers1?.Count > 0)
						{
							var @handler = this.Expectations.handlers1[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						
						throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for int IAmNotADim()");
					}
					
					[global::Rocks.MemberIdentifier(2, "get_AmADim()")]
					public int AmADim
					{
						get
						{
							if (this.Expectations.handlers2?.Count > 0)
							{
								var @handler = this.Expectations.handlers2[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							else
							{
								return this.shimForIHaveDims.AmADim;
							}
						}
					}
					[global::Rocks.MemberIdentifier(4, "get_NotDim()")]
					public int NotDim
					{
						get
						{
							if (this.Expectations.handlers4?.Count > 0)
							{
								var @handler = this.Expectations.handlers4[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for get_NotDim())");
						}
					}
					
					[global::Rocks.MemberIdentifier(3, "this[string @dimKey, int @dimValue]")]
					public int this[string @dimKey, int @dimValue]
					{
						get
						{
							if (this.Expectations.handlers3?.Count > 0)
							{
								foreach (var @handler in this.Expectations.handlers3)
								{
									if (@handler.@dimKey.IsValid(@dimKey!) &&
										@handler.@dimValue.IsValid(@dimValue!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@dimKey!, @dimValue!) : @handler.ReturnValue;
										return @result!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for this[string @dimKey, int @dimValue]");
							}
							else
							{
								return this.shimForIHaveDims[dimKey: @dimKey!, dimValue: @dimValue!];
							}
						}
					}
					[global::Rocks.MemberIdentifier(5, "this[string @notDimKey]")]
					public int this[string @notDimKey]
					{
						get
						{
							if (this.Expectations.handlers5?.Count > 0)
							{
								foreach (var @handler in this.Expectations.handlers5)
								{
									if (@handler.@notDimKey.IsValid(@notDimKey!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@notDimKey!) : @handler.ReturnValue;
										return @result!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for this[string @notDimKey]");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for this[string @notDimKey])");
						}
					}
					
					
					private sealed class ShimIHaveDims
						: global::IHaveDims
					{
						private readonly Mock mock;
						
						public ShimIHaveDims(Mock @mock) =>
							this.mock = @mock;
						
						public int IAmNotADim() =>
							((global::IHaveDims)this.mock).IAmNotADim()!;
						
						public int NotDim
						{
							get => ((global::IHaveDims)this.mock).NotDim!;
						}
						
						public int this[string @notDimKey]
						{
							get => ((global::IHaveDims)this.mock)[@notDimKey]!;
						}
					}
					private global::IHaveDimsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveDimsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler0, global::System.Func<int>, int> IAmADim()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						var handler = new global::IHaveDimsCreateExpectations.Handler0();
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler1, global::System.Func<int>, int> IAmNotADim()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(); }
						var handler = new global::IHaveDimsCreateExpectations.Handler1();
						this.Expectations.handlers1.Add(handler);
						return new(handler);
					}
					
					private global::IHaveDimsCreateExpectations Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IHaveDimsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler2, global::System.Func<int>, int> AmADim()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(); }
							var handler = new global::IHaveDimsCreateExpectations.Handler2();
							this.Expectations.handlers2.Add(handler);
							return new(handler);
						}
						internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler4, global::System.Func<int>, int> NotDim()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers4 is null ) { this.Expectations.handlers4 = new(); }
							var handler = new global::IHaveDimsCreateExpectations.Handler4();
							this.Expectations.handlers4.Add(handler);
							return new(handler);
						}
						private global::IHaveDimsCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IHaveDimsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveDimsCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IHaveDimsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler3, global::System.Func<string, int, int>, int> This(global::Rocks.Argument<string> @dimKey, global::Rocks.Argument<int> @dimValue)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@dimKey);
							global::System.ArgumentNullException.ThrowIfNull(@dimValue);
							
							var @handler = new global::IHaveDimsCreateExpectations.Handler3
							{
								@dimKey = @dimKey,
								@dimValue = @dimValue,
							};
							
							if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(); }
							this.Expectations.handlers3.Add(@handler);
							return new(@handler);
						}
						internal global::Rocks.Adornments<global::IHaveDimsCreateExpectations.Handler5, global::System.Func<string, int>, int> This(global::Rocks.Argument<string> @notDimKey)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@notDimKey);
							
							var @handler = new global::IHaveDimsCreateExpectations.Handler5
							{
								@notDimKey = @notDimKey,
							};
							
							if (this.Expectations.handlers5 is null ) { this.Expectations.handlers5 = new(); }
							this.Expectations.handlers5.Add(@handler);
							return new(@handler);
						}
						private global::IHaveDimsCreateExpectations Expectations { get; }
					}
					
					
					internal IndexerExpectations(global::IHaveDimsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveDimsCreateExpectations.IndexerExpectations.IndexerGetterExpectations Getters { get; }
				}
				
				internal global::IHaveDimsCreateExpectations.MethodExpectations Methods { get; }
				internal global::IHaveDimsCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IHaveDimsCreateExpectations.IndexerExpectations Indexers { get; }
				
				internal IHaveDimsCreateExpectations() =>
					(this.Methods, this.Properties, this.Indexers) = (new(this), new(this), new(this));
				
				internal global::IHaveDims Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IHaveDims_Rock_Create.g.cs", generatedCode) },
			[]);
	}
}