using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Testing;
using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class NullabilityGeneratorTests
{
	[Test]
	public static async Task GenerateWithAllowNullParameterAndDefaultValueAsync()
	{
		var code =
			"""
			using Rocks;
			using System.Diagnostics.CodeAnalysis;

			[assembly: RockCreate<ConnectionBuilder<object>>]

			#nullable enable

			public interface IGraphType { }

			public class ConnectionBuilder<TSourceType>
			{
				public virtual ConnectionBuilder<TSourceType> Argument<TArgumentGraphType, TArgumentType>(string name, string? description,
					[AllowNull] TArgumentType defaultValue = default!)
						where TArgumentGraphType : IGraphType => new();
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class ConnectionBuilderOfobjectCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::ConnectionBuilderOfobjectCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::ConnectionBuilderOfobjectCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::ConnectionBuilderOfobjectCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3<TArgumentGraphType, TArgumentType>
					: global::Rocks.Handler<global::System.Func<string, string?, TArgumentType, global::ConnectionBuilder<object>>, global::ConnectionBuilder<object>>
					where TArgumentGraphType : global::IGraphType
				{
					public global::Rocks.Argument<string> @name { get; set; }
					public global::Rocks.Argument<string?> @description { get; set; }
					public global::Rocks.Argument<TArgumentType> @defaultValue { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers3;
				#pragma warning restore CS8618
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::ConnectionBuilder<object>
				{
					public Mock(global::ConnectionBuilderOfobjectCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3)]
					public override global::ConnectionBuilder<object> Argument<TArgumentGraphType, TArgumentType>(string @name, string? @description, [global::System.Diagnostics.CodeAnalysis.AllowNullAttribute] TArgumentType @defaultValue = default!)
					{
						if (this.Expectations.handlers3 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers3)
							{
								if (@genericHandler is global::ConnectionBuilderOfobjectCreateExpectations.Handler3<TArgumentGraphType, TArgumentType> @handler)
								{
									if (@handler.@name.IsValid(@name!) &&
										@handler.@description.IsValid(@description!) &&
										@handler.@defaultValue.IsValid(@defaultValue!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@name!, @description!, @defaultValue!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(3)}");
						}
						else
						{
							return base.Argument<TArgumentGraphType, TArgumentType>(name: @name!, description: @description!, defaultValue: @defaultValue!);
						}
					}
					
					private global::ConnectionBuilderOfobjectCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::ConnectionBuilderOfobjectCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::ConnectionBuilderOfobjectCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::ConnectionBuilderOfobjectCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::ConnectionBuilderOfobjectCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::ConnectionBuilderOfobjectCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::ConnectionBuilderOfobjectCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::ConnectionBuilderOfobjectCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::ConnectionBuilderOfobjectCreateExpectations.Adornments.AdornmentsForHandler3<TArgumentGraphType, TArgumentType> Argument<TArgumentGraphType, TArgumentType>(global::Rocks.Argument<string> @name, global::Rocks.Argument<string?> @description, global::Rocks.Argument<TArgumentType> @defaultValue) where TArgumentGraphType : global::IGraphType
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@name);
						global::System.ArgumentNullException.ThrowIfNull(@description);
						global::System.ArgumentNullException.ThrowIfNull(@defaultValue);
						
						var @handler = new global::ConnectionBuilderOfobjectCreateExpectations.Handler3<TArgumentGraphType, TArgumentType>
						{
							@name = @name,
							@description = @description,
							@defaultValue = @defaultValue.Transform(default!),
						};
						
						if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(@handler); }
						else { this.Expectations.handlers3.Add(@handler); }
						return new(@handler);
					}
					internal global::ConnectionBuilderOfobjectCreateExpectations.Adornments.AdornmentsForHandler3<TArgumentGraphType, TArgumentType> Argument<TArgumentGraphType, TArgumentType>(global::Rocks.Argument<string> @name, global::Rocks.Argument<string?> @description, TArgumentType @defaultValue = default!) where TArgumentGraphType : global::IGraphType =>
						this.Argument<TArgumentGraphType, TArgumentType>(@name, @description, global::Rocks.Arg.Is(@defaultValue));
					
					private global::ConnectionBuilderOfobjectCreateExpectations Expectations { get; }
				}
				
				internal global::ConnectionBuilderOfobjectCreateExpectations.MethodExpectations Methods { get; }
				
				internal ConnectionBuilderOfobjectCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::ConnectionBuilder<object> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForConnectionBuilderOfobject<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForConnectionBuilderOfobject<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::ConnectionBuilderOfobjectCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForConnectionBuilderOfobject<AdornmentsForHandler0>
					{ 
						public AdornmentsForHandler0(global::ConnectionBuilderOfobjectCreateExpectations.Handler0 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::ConnectionBuilderOfobjectCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForConnectionBuilderOfobject<AdornmentsForHandler1>
					{ 
						public AdornmentsForHandler1(global::ConnectionBuilderOfobjectCreateExpectations.Handler1 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::ConnectionBuilderOfobjectCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForConnectionBuilderOfobject<AdornmentsForHandler2>
					{ 
						public AdornmentsForHandler2(global::ConnectionBuilderOfobjectCreateExpectations.Handler2 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler3<TArgumentGraphType, TArgumentType>
						: global::Rocks.Adornments<AdornmentsForHandler3<TArgumentGraphType, TArgumentType>, global::ConnectionBuilderOfobjectCreateExpectations.Handler3<TArgumentGraphType, TArgumentType>, global::System.Func<string, string?, TArgumentType, global::ConnectionBuilder<object>>, global::ConnectionBuilder<object>>, IAdornmentsForConnectionBuilderOfobject<AdornmentsForHandler3<TArgumentGraphType, TArgumentType>> where TArgumentGraphType : global::IGraphType
					{ 
						public AdornmentsForHandler3(global::ConnectionBuilderOfobjectCreateExpectations.Handler3<TArgumentGraphType, TArgumentType> handler)
							: base(handler) { }				
					}
				}
			}
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "ConnectionBuilderobject_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenNullabilityChangesInOverrideAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<SubTracer>]

			#nullable enable

			public class Tracer
			{
				public virtual void TraceEvent(string? eventCache, string source, 
					string eventType, int id, 
					string? format, params object?[]? args)
				{ }
			}

			public class SubTracer
				: Tracer
			{
				public override void TraceEvent(string eventCache, string source, 
					string eventType, int id, 
					string format, params object[] args)
				{ }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class SubTracerCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler4
					: global::Rocks.Handler<global::System.Action<string, string, string, int, string, object[]>>
				{
					public global::Rocks.Argument<string> @eventCache { get; set; }
					public global::Rocks.Argument<string> @source { get; set; }
					public global::Rocks.Argument<string> @eventType { get; set; }
					public global::Rocks.Argument<int> @id { get; set; }
					public global::Rocks.Argument<string> @format { get; set; }
					public global::Rocks.Argument<object[]> @args { get; set; }
				}
				private global::Rocks.Handlers<global::SubTracerCreateExpectations.Handler4>? @handlers4;
				#pragma warning restore CS8618
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers4 is not null) { failures.AddRange(this.Verify(this.handlers4, 4)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::SubTracer
				{
					public Mock(global::SubTracerCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(4)]
					public override void TraceEvent(string @eventCache, string @source, string @eventType, int @id, string @format, params object[] @args)
					{
						if (this.Expectations.handlers4 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers4)
							{
								if (@handler.@eventCache.IsValid(@eventCache!) &&
									@handler.@source.IsValid(@source!) &&
									@handler.@eventType.IsValid(@eventType!) &&
									@handler.@id.IsValid(@id!) &&
									@handler.@format.IsValid(@format!) &&
									@handler.@args.IsValid(@args!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@eventCache!, @source!, @eventType!, @id!, @format!, @args!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(4)}");
							}
						}
						else
						{
							base.TraceEvent(eventCache: @eventCache!, source: @source!, eventType: @eventType!, id: @id!, format: @format!, args: @args!);
						}
					}
					
					private global::SubTracerCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::SubTracerCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::SubTracerCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::SubTracerCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::SubTracerCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::SubTracerCreateExpectations.Adornments.AdornmentsForHandler4 TraceEvent(global::Rocks.Argument<string> @eventCache, global::Rocks.Argument<string> @source, global::Rocks.Argument<string> @eventType, global::Rocks.Argument<int> @id, global::Rocks.Argument<string> @format, global::Rocks.Argument<object[]> @args)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@eventCache);
						global::System.ArgumentNullException.ThrowIfNull(@source);
						global::System.ArgumentNullException.ThrowIfNull(@eventType);
						global::System.ArgumentNullException.ThrowIfNull(@id);
						global::System.ArgumentNullException.ThrowIfNull(@format);
						global::System.ArgumentNullException.ThrowIfNull(@args);
						
						var @handler = new global::SubTracerCreateExpectations.Handler4
						{
							@eventCache = @eventCache,
							@source = @source,
							@eventType = @eventType,
							@id = @id,
							@format = @format,
							@args = @args,
						};
						
						if (this.Expectations.handlers4 is null ) { this.Expectations.handlers4 = new(@handler); }
						else { this.Expectations.handlers4.Add(@handler); }
						return new(@handler);
					}
					
					private global::SubTracerCreateExpectations Expectations { get; }
				}
				
				internal global::SubTracerCreateExpectations.MethodExpectations Methods { get; }
				
				internal SubTracerCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::SubTracer Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForSubTracer<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForSubTracer<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::SubTracerCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForSubTracer<AdornmentsForHandler0>
					{ 
						public AdornmentsForHandler0(global::SubTracerCreateExpectations.Handler0 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::SubTracerCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForSubTracer<AdornmentsForHandler1>
					{ 
						public AdornmentsForHandler1(global::SubTracerCreateExpectations.Handler1 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::SubTracerCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForSubTracer<AdornmentsForHandler2>
					{ 
						public AdornmentsForHandler2(global::SubTracerCreateExpectations.Handler2 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler4
						: global::Rocks.Adornments<AdornmentsForHandler4, global::SubTracerCreateExpectations.Handler4, global::System.Action<string, string, string, int, string, object[]>>, IAdornmentsForSubTracer<AdornmentsForHandler4>
					{ 
						public AdornmentsForHandler4(global::SubTracerCreateExpectations.Handler4 handler)
							: base(handler) { }				
					}
				}
			}
			
			""";

		// The two diagnostic IDs are actually warnings, so they
		// can be ignored/suppressed. They show up because the override
		// continues the problem that the subtype introduces when it changes
		// the nullability annotations.
		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "SubTracer_Rock_Create.g.cs", generatedCode)],
			[
				new DiagnosticResult("CS8610", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("args"),
				new DiagnosticResult("CS8765", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("eventCache"),
				new DiagnosticResult("CS8765", DiagnosticSeverity.Error)
					.WithSpan(18, 23, 18, 33).WithArguments("format"),
			]);
	}

	[Test]
	public static async Task GenerateWhenPropertyInShimNeedsNullForgivingAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<IConventionSkipNavigation>]

			#nullable enable

			public interface IReadOnlyNavigationBase
			{
				IReadOnlyNavigationBase? Inverse { get; }
			}

			public interface IReadOnlySkipNavigation
				: IReadOnlyNavigationBase
			{
				new IReadOnlySkipNavigation Inverse { get; }

				IReadOnlyNavigationBase IReadOnlyNavigationBase.Inverse
				{
					get => Inverse;
				}
			}

			public interface IConventionSkipNavigation 
				: IReadOnlySkipNavigation
			{
				new IConventionSkipNavigation? Inverse
				{
					get => (IConventionSkipNavigation?)((IReadOnlySkipNavigation)this).Inverse;
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IConventionSkipNavigationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::IConventionSkipNavigation?>, global::IConventionSkipNavigation?>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<global::IReadOnlySkipNavigation>, global::IReadOnlySkipNavigation>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::IReadOnlyNavigationBase?>, global::IReadOnlyNavigationBase?>
				{ }
				private global::Rocks.Handlers<global::IConventionSkipNavigationCreateExpectations.Handler2>? @handlers2;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IConventionSkipNavigation
				{
					private readonly global::IConventionSkipNavigation shimForIConventionSkipNavigation;
					public Mock(global::IConventionSkipNavigationCreateExpectations @expectations)
					{
						(this.Expectations, this.shimForIConventionSkipNavigation) = (@expectations, new ShimIConventionSkipNavigation(this));
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public global::IConventionSkipNavigation? Inverse
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							else
							{
								return this.shimForIConventionSkipNavigation.Inverse;
							}
						}
					}
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Get)]
					global::IReadOnlySkipNavigation global::IReadOnlySkipNavigation.Inverse
					{
						get
						{
							if (this.Expectations.handlers1 is not null)
							{
								var @handler = this.Expectations.handlers1.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)})");
						}
					}
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					global::IReadOnlyNavigationBase? global::IReadOnlyNavigationBase.Inverse
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(2)})");
						}
					}
					
					
					private sealed class ShimIConventionSkipNavigation
						: global::IConventionSkipNavigation
					{
						private readonly Mock mock;
						
						public ShimIConventionSkipNavigation(Mock @mock) =>
							this.mock = @mock;
						
						global::IReadOnlySkipNavigation global::IReadOnlySkipNavigation.Inverse
						{
							get => ((global::IConventionSkipNavigation)this.mock).Inverse!;
						}
						
						global::IReadOnlyNavigationBase? global::IReadOnlyNavigationBase.Inverse
						{
							get => ((global::IConventionSkipNavigation)this.mock).Inverse!;
						}
					}
					private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler0 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler0();
							if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlySkipNavigation
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler1 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler1();
							if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(handler); }
							else { this.Expectations.handlers1.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlySkipNavigation(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlySkipNavigation.ExplicitPropertyGetterExpectationsForIReadOnlySkipNavigation Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIReadOnlyNavigationBase
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase
					{
						internal ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase(global::IConventionSkipNavigationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IConventionSkipNavigationCreateExpectations.Adornments.AdornmentsForHandler2 Inverse()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IConventionSkipNavigationCreateExpectations.Handler2();
							if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IConventionSkipNavigationCreateExpectations Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIReadOnlyNavigationBase(global::IConventionSkipNavigationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyNavigationBase.ExplicitPropertyGetterExpectationsForIReadOnlyNavigationBase Getters { get; }
				}
				
				internal global::IConventionSkipNavigationCreateExpectations.PropertyExpectations Properties { get; }
				internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlySkipNavigation ExplicitPropertiesForIReadOnlySkipNavigation { get; }
				internal global::IConventionSkipNavigationCreateExpectations.ExplicitPropertyExpectationsForIReadOnlyNavigationBase ExplicitPropertiesForIReadOnlyNavigationBase { get; }
				
				internal IConventionSkipNavigationCreateExpectations() =>
					(this.Properties, this.ExplicitPropertiesForIReadOnlySkipNavigation, this.ExplicitPropertiesForIReadOnlyNavigationBase) = (new(this), new(this), new(this));
				
				internal global::IConventionSkipNavigation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIConventionSkipNavigation<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIConventionSkipNavigation<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IConventionSkipNavigationCreateExpectations.Handler0, global::System.Func<global::IConventionSkipNavigation?>, global::IConventionSkipNavigation?>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler0>
					{ 
						public AdornmentsForHandler0(global::IConventionSkipNavigationCreateExpectations.Handler0 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IConventionSkipNavigationCreateExpectations.Handler1, global::System.Func<global::IReadOnlySkipNavigation>, global::IReadOnlySkipNavigation>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler1>
					{ 
						public AdornmentsForHandler1(global::IConventionSkipNavigationCreateExpectations.Handler1 handler)
							: base(handler) { }				
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IConventionSkipNavigationCreateExpectations.Handler2, global::System.Func<global::IReadOnlyNavigationBase?>, global::IReadOnlyNavigationBase?>, IAdornmentsForIConventionSkipNavigation<AdornmentsForHandler2>
					{ 
						public AdornmentsForHandler2(global::IConventionSkipNavigationCreateExpectations.Handler2 handler)
							: base(handler) { }				
					}
				}
			}
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IConventionSkipNavigation_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenTargetIsInterfaceAndMethodIsConstrainedByTypeParameterThatIsAssignedAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<IDestination<object>>]

			public interface IDestination<TDestination>
			{
				void As<T>() where T : TDestination;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IDestinationOfobjectCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0<T>
					: global::Rocks.Handler<global::System.Action>
					where T : notnull
				{ }
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IDestination<object>
				{
					public Mock(global::IDestinationOfobjectCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void As<T>()
						where T : notnull
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @genericHandler = this.Expectations.handlers0.First;
							if (@genericHandler is global::IDestinationOfobjectCreateExpectations.Handler0<T> @handler)
							{
								@handler.CallCount++;
								@handler.Callback?.Invoke();
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException($"The provided handler does not match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IDestinationOfobjectCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IDestinationOfobjectCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IDestinationOfobjectCreateExpectations.Adornments.AdornmentsForHandler0<T> As<T>() where T : notnull
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IDestinationOfobjectCreateExpectations.Handler0<T>();
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					private global::IDestinationOfobjectCreateExpectations Expectations { get; }
				}
				
				internal global::IDestinationOfobjectCreateExpectations.MethodExpectations Methods { get; }
				
				internal IDestinationOfobjectCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IDestination<object> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIDestinationOfobject<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIDestinationOfobject<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0<T>
						: global::Rocks.Adornments<AdornmentsForHandler0<T>, global::IDestinationOfobjectCreateExpectations.Handler0<T>, global::System.Action>, IAdornmentsForIDestinationOfobject<AdornmentsForHandler0<T>> where T : notnull
					{ 
						public AdornmentsForHandler0(global::IDestinationOfobjectCreateExpectations.Handler0<T> handler)
							: base(handler) { }				
					}
				}
			}
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IDestinationobject_Rock_Create.g.cs", generatedCode)],
			[]);
	}
}