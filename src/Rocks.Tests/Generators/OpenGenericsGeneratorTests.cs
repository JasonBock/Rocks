using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class OpenGenericsGeneratorTests
{
	[Test]
	public static async Task GenerateWithExplicitImplementationsAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Diagnostics.CodeAnalysis;
						
			[assembly: Rock(typeof(IRequest<,,>), BuildType.Create | BuildType.Make)]
			
			#nullable enable
			
			public interface IRequestSettings<TResponse>
				where TResponse : class 
			{ }

			public interface IRequest<TResponse>
				where TResponse : class
			{
				IRequestSettings<TResponse> Settings { get; }
			}			
			
			public interface IRequestSettings<TResponse, TResponse2>
				: IRequestSettings<TResponse>
				where TResponse : class 
				where TResponse2 : class
			{ }
			
			public interface IRequest<TResponse, TResponse2>
				: IRequest<TResponse>
				where TResponse : class
				where TResponse2 : class
			{
				new IRequestSettings<TResponse, TResponse2> Settings { get; }
			}			
			
			public interface IRequestSettings<TResponse, TResponse2, TResponse3>
				: IRequestSettings<TResponse, TResponse2>
				where TResponse : class 
				where TResponse2 : class
				where TResponse3 : class
			{ }
			
			public interface IRequest<TResponse, TResponse2, TResponse3>
				: IRequest<TResponse, TResponse2>
				where TResponse : class
				where TResponse2 : class
				where TResponse3 : class
			{
				new IRequestSettings<TResponse, TResponse2, TResponse3> Settings { get; }
			}
			""";

		var createGeneratedCode = 
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IRequestCreateExpectations<TResponse, TResponse2, TResponse3>
				: global::Rocks.Expectations
				where TResponse : class
				where TResponse2 : class
				where TResponse3 : class
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::IRequestSettings<TResponse, TResponse2, TResponse3>>, global::IRequestSettings<TResponse, TResponse2, TResponse3>>
				{ }
				private global::Rocks.Handlers<global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<global::IRequestSettings<TResponse, TResponse2>>, global::IRequestSettings<TResponse, TResponse2>>
				{ }
				private global::Rocks.Handlers<global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::IRequestSettings<TResponse>>, global::IRequestSettings<TResponse>>
				{ }
				private global::Rocks.Handlers<global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler2>? @handlers2;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IRequest<TResponse, TResponse2, TResponse3>
				{
					public Mock(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public global::IRequestSettings<TResponse, TResponse2, TResponse3> Settings
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)})");
						}
					}
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Get)]
					global::IRequestSettings<TResponse, TResponse2> global::IRequest<TResponse, TResponse2>.Settings
					{
						get
						{
							if (this.Expectations.handlers1 is not null)
							{
								var @handler = this.Expectations.handlers1.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)})");
						}
					}
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					global::IRequestSettings<TResponse> global::IRequest<TResponse>.Settings
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(2)})");
						}
					}
					
					private global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
							this.Expectations = expectations;
						
						internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Adornments.AdornmentsForHandler0 Settings()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIRequestOfTResponse_TResponse2
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIRequestOfTResponse_TResponse2
					{
						internal ExplicitPropertyGetterExpectationsForIRequestOfTResponse_TResponse2(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
							this.Expectations = expectations;
						
						internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Adornments.AdornmentsForHandler1 Settings()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler1();
							if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
							else { this.Expectations.handlers1.Add(handler); }
							return new(handler);
						}
						private global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIRequestOfTResponse_TResponse2(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.ExplicitPropertyExpectationsForIRequestOfTResponse_TResponse2.ExplicitPropertyGetterExpectationsForIRequestOfTResponse_TResponse2 Getters { get; }
				}
				internal sealed class ExplicitPropertyExpectationsForIRequestOfTResponse
				{
					internal sealed class ExplicitPropertyGetterExpectationsForIRequestOfTResponse
					{
						internal ExplicitPropertyGetterExpectationsForIRequestOfTResponse(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
							this.Expectations = expectations;
						
						internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Adornments.AdornmentsForHandler2 Settings()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler2();
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> Expectations { get; }
					}
					
					internal ExplicitPropertyExpectationsForIRequestOfTResponse(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3> expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.ExplicitPropertyExpectationsForIRequestOfTResponse.ExplicitPropertyGetterExpectationsForIRequestOfTResponse Getters { get; }
				}
				
				internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.PropertyExpectations Properties { get; }
				internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.ExplicitPropertyExpectationsForIRequestOfTResponse_TResponse2 ExplicitPropertiesForIRequestOfTResponse_TResponse2 { get; }
				internal global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.ExplicitPropertyExpectationsForIRequestOfTResponse ExplicitPropertiesForIRequestOfTResponse { get; }
				
				internal IRequestCreateExpectations() =>
					(this.Properties, this.ExplicitPropertiesForIRequestOfTResponse_TResponse2, this.ExplicitPropertiesForIRequestOfTResponse) = (new(this), new(this), new(this));
				
				internal global::IRequest<TResponse, TResponse2, TResponse3> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIRequest<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIRequest<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler0, global::System.Func<global::IRequestSettings<TResponse, TResponse2, TResponse3>>, global::IRequestSettings<TResponse, TResponse2, TResponse3>>, IAdornmentsForIRequest<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler1, global::System.Func<global::IRequestSettings<TResponse, TResponse2>>, global::IRequestSettings<TResponse, TResponse2>>, IAdornmentsForIRequest<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler2, global::System.Func<global::IRequestSettings<TResponse>>, global::IRequestSettings<TResponse>>, IAdornmentsForIRequest<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IRequestCreateExpectations<TResponse, TResponse2, TResponse3>.Handler2 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IRequestMakeExpectations<TResponse, TResponse2, TResponse3>
				where TResponse : class
				where TResponse2 : class
				where TResponse3 : class
			{
				internal global::IRequest<TResponse, TResponse2, TResponse3> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IRequest<TResponse, TResponse2, TResponse3>
				{
					public Mock()
					{
					}
					
					public global::IRequestSettings<TResponse, TResponse2, TResponse3> Settings
					{
						get => default!;
					}
					global::IRequestSettings<TResponse, TResponse2> global::IRequest<TResponse, TResponse2>.Settings
					{
						get => default!;
					}
					global::IRequestSettings<TResponse> global::IRequest<TResponse>.Settings
					{
						get => default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				(typeof(RockGenerator), "IRequestTResponse, TResponse2, TResponse3_Rock_Create.g.cs", createGeneratedCode),
				(typeof(RockGenerator), "IRequestTResponse, TResponse2, TResponse3_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task CreateWhenNullableOpenGenericsExistAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Diagnostics.CodeAnalysis;
						
			[assembly: RockCreate(typeof(IConsumerContext<>))]
			
			#nullable enable
			
			public interface IPipeContext
			{
				bool TryGetPayload<T>([NotNullWhen(true)] out T? payload) where T : class;
			}

			public interface IConsumerContext<out T> :
				IPipeContext
				where T : class
			{
				void Consume(string message);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IConsumerContextCreateExpectations<T>
				: global::Rocks.Expectations
				where T : class
			{
				internal static class Projections
				{
					internal delegate bool Callback_2208149965646553682949667918893738772205946588<T1>([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)]out T1? @payload) where T1 : class;
				}
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<string>>
				{
					public global::Rocks.Argument<string> @message { get; set; }
				}
				private global::Rocks.Handlers<global::IConsumerContextCreateExpectations<T>.Handler0>? @handlers0;
				internal sealed class Handler1<T1>
					: global::Rocks.Handler<global::IConsumerContextCreateExpectations<T>.Projections.Callback_2208149965646553682949667918893738772205946588<T1>, bool>
					where T1 : class
				{
					public global::Rocks.Argument<T1?> @payload { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers1;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IConsumerContext<T>
				{
					public Mock(global::IConsumerContextCreateExpectations<T> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Consume(string @message)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@message.IsValid(@message!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@message!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public bool TryGetPayload<T1>([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out T1? @payload)
						where T1 : class
					{
						@payload = default!;
						if (this.Expectations.handlers1 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers1)
							{
								if (@genericHandler is global::IConsumerContextCreateExpectations<T>.Handler1<T1> @handler)
								{
									if (@handler.@payload.IsValid(@payload!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(out @payload!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(1)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)}");
					}
					
					private global::IConsumerContextCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IConsumerContextCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::IConsumerContextCreateExpectations<T>.Adornments.AdornmentsForHandler0 Consume(global::Rocks.Argument<string> @message)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@message);
						
						var @handler = new global::IConsumerContextCreateExpectations<T>.Handler0
						{
							@message = @message,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal global::IConsumerContextCreateExpectations<T>.Adornments.AdornmentsForHandler1<T1> TryGetPayload<T1>(global::Rocks.Argument<T1?> @payload) where T1 : class
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@payload);
						
						var @handler = new global::IConsumerContextCreateExpectations<T>.Handler1<T1>
						{
							@payload = global::Rocks.Arg.Any<T1?>(),
						};
						
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(@handler); }
						else { this.Expectations.handlers1.Add(@handler); }
						return new(@handler);
					}
					
					private global::IConsumerContextCreateExpectations<T> Expectations { get; }
				}
				
				internal global::IConsumerContextCreateExpectations<T>.MethodExpectations Methods { get; }
				
				internal IConsumerContextCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IConsumerContext<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIConsumerContext<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIConsumerContext<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IConsumerContextCreateExpectations<T>.Handler0, global::System.Action<string>>, IAdornmentsForIConsumerContext<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IConsumerContextCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1<T1>
						: global::Rocks.Adornments<AdornmentsForHandler1<T1>, global::IConsumerContextCreateExpectations<T>.Handler1<T1>, global::IConsumerContextCreateExpectations<T>.Projections.Callback_2208149965646553682949667918893738772205946588<T1>, bool>, IAdornmentsForIConsumerContext<AdornmentsForHandler1<T1>> where T1 : class
					{
						public AdornmentsForHandler1(global::IConsumerContextCreateExpectations<T>.Handler1<T1> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IConsumerContextT_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWhenNullableOpenGenericsExistAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Diagnostics.CodeAnalysis;
						
			[assembly: RockMake(typeof(IConsumerContext<>))]
			
			#nullable enable
			
			public interface IPipeContext
			{
				bool TryGetPayload<T>([NotNullWhen(true)] out T? payload) where T : class;
			}

			public interface IConsumerContext<out T> :
				IPipeContext
				where T : class
			{
				void Consume(string message);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IConsumerContextMakeExpectations<T>
				where T : class
			{
				internal global::IConsumerContext<T> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IConsumerContext<T>
				{
					public Mock()
					{
					}
					
					public void Consume(string @message)
					{
					}
					public bool TryGetPayload<T1>([global::System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] out T1? @payload)
						where T1 : class
					{
						@payload = default!;
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IConsumerContextT_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWhenEventExistsAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(IService<>))]
			
			#nullable enable

			public interface IService<T>
			{
				void Run(T value);

				event EventHandler MyEvent;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775

			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceCreateExpectations<T>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<T>>
				{
					public global::Rocks.Argument<T> @value { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IService<T>, global::Rocks.IRaiseEvents
				{
					public Mock(global::IServiceCreateExpectations<T> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Run(T @value)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@value.IsValid(@value!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@value!);
									@handler.RaiseEvents(this);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					#pragma warning disable CS0067
					public event global::System.EventHandler? MyEvent;
					#pragma warning restore CS0067
					
					void global::Rocks.IRaiseEvents.Raise(string @fieldName, object @args)
					{
						var @thisType = this.GetType();
						var @eventDelegate = (global::System.MulticastDelegate)thisType.GetField(@fieldName, 
							global::System.Reflection.BindingFlags.Instance | global::System.Reflection.BindingFlags.NonPublic)!.GetValue(this)!;
						
						if (@eventDelegate is not null)
						{
							foreach (var @handler in @eventDelegate.GetInvocationList())
							{
								@handler.Method.Invoke(@handler.Target, new object[]{this, @args});
							}
						}
					}
					
					private global::IServiceCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IServiceCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::IServiceCreateExpectations<T>.Adornments.AdornmentsForHandler0 Run(global::Rocks.Argument<T> @value)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@value);
						
						var @handler = new global::IServiceCreateExpectations<T>.Handler0
						{
							@value = @value,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IServiceCreateExpectations<T> Expectations { get; }
				}
				
				internal global::IServiceCreateExpectations<T>.MethodExpectations Methods { get; }
				
				internal IServiceCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IService<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IServiceCreateExpectations<T>.Handler0, global::System.Action<T>>, IAdornmentsForIService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IServiceCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(IService<,>))]
			
			#nullable enable

			public interface IService<T, TReturn>
			{
				TReturn Service(T data);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceCreateExpectations<T, TReturn>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<T, TReturn>, TReturn>
				{
					public global::Rocks.Argument<T> @data { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IService<T, TReturn>
				{
					public Mock(global::IServiceCreateExpectations<T, TReturn> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public TReturn Service(T @data)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@data.IsValid(@data!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@data!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
						this.Expectations = expectations;
					
					internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler0 Service(global::Rocks.Argument<T> @data)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@data);
						
						var @handler = new global::IServiceCreateExpectations<T, TReturn>.Handler0
						{
							@data = @data,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
				}
				
				internal global::IServiceCreateExpectations<T, TReturn>.MethodExpectations Methods { get; }
				
				internal IServiceCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IService<T, TReturn> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IServiceCreateExpectations<T, TReturn>.Handler0, global::System.Func<T, TReturn>, TReturn>, IAdornmentsForIService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IServiceCreateExpectations<T, TReturn>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT, TReturn_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockMake(typeof(IService<,>))]
			
			#nullable enable

			public interface IService<T, TReturn>
			{
				TReturn Service(T data);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceMakeExpectations<T, TReturn>
			{
				internal global::IService<T, TReturn> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IService<T, TReturn>
				{
					public Mock()
					{
					}
					
					public TReturn Service(T @data)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT, TReturn_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithPropertiesAndIndexersAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(IService<,>))]
			
			#nullable enable

			public interface IService<T, TReturn>
			{
				T Data { get; set; }
				TReturn this[TReturn index] { get; set; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceCreateExpectations<T, TReturn>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<T>, T>
				{ }
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Action<T>>
				{
					public global::Rocks.Argument<T> @value { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<TReturn, TReturn>, TReturn>
				{
					public global::Rocks.Argument<TReturn> @index { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action<TReturn, TReturn>>
				{
					public global::Rocks.Argument<TReturn> @index { get; set; }
					public global::Rocks.Argument<TReturn> @value { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IService<T, TReturn>
				{
					public Mock(global::IServiceCreateExpectations<T, TReturn> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Set)]
					public T Data
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)})");
						}
						set
						{
							if (this.Expectations.handlers1 is not null)
							{
								var @foundMatch = false;
								foreach (var @handler in this.Expectations.handlers1)
								{
									if (@handler.value.IsValid(value!))
									{
										@handler.CallCount++;
										@foundMatch = true;
										@handler.Callback?.Invoke(value!);
										
										if (!@foundMatch)
										{
											throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(1)}");
										}
										
										break;
									}
								}
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)}");
							}
						}
					}
					
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					[global::Rocks.MemberIdentifier(3, global::Rocks.PropertyAccessor.Set)]
					public TReturn this[TReturn @index]
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								foreach (var @handler in this.Expectations.handlers2)
								{
									if (@handler.@index.IsValid(@index!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@index!) : @handler.ReturnValue;
										return @result!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(2)}");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(2)})");
						}
						set
						{
							if (this.Expectations.handlers3 is not null)
							{
								foreach (var @handler in this.Expectations.handlers3)
								{
									if (@handler.@index.IsValid(@index!) &&
										@handler.@value.IsValid(@value!))
									{
										@handler.CallCount++;
										@handler.Callback?.Invoke(@index!, @value!);
										return;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(3)}");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(3)}");
						}
					}
					
					private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
							this.Expectations = expectations;
						
						internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler0 Data()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IServiceCreateExpectations<T, TReturn>.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
					}
					
					internal sealed class PropertySetterExpectations
					{
						internal PropertySetterExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
							this.Expectations = expectations;
						
						internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler1 Data(global::Rocks.Argument<T> @value)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@value);
						
							var handler = new global::IServiceCreateExpectations<T, TReturn>.Handler1
							{
								value = @value,
							};
						
							if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
							else { this.Expectations.handlers1.Add(handler); }
							return new(handler);
						}
						private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
					}
					
					internal PropertyExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
						(this.Getters, this.Setters) = (new(expectations), new(expectations));
					
					internal global::IServiceCreateExpectations<T, TReturn>.PropertyExpectations.PropertyGetterExpectations Getters { get; }
					internal global::IServiceCreateExpectations<T, TReturn>.PropertyExpectations.PropertySetterExpectations Setters { get; }
				}
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
							this.Expectations = expectations;
						
						internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler2 This(global::Rocks.Argument<TReturn> @index)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@index);
							
							var @handler = new global::IServiceCreateExpectations<T, TReturn>.Handler2
							{
								@index = @index,
							};
							
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(@handler); }
							else { this.Expectations.handlers2.Add(@handler); }
							return new(@handler);
						}
						private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
					}
					
					internal sealed class IndexerSetterExpectations
					{
						internal IndexerSetterExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
							this.Expectations = expectations;
						
						internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler3 This(global::Rocks.Argument<TReturn> @value, global::Rocks.Argument<TReturn> @index)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@index);
							global::System.ArgumentNullException.ThrowIfNull(@value);
							
							var @handler = new global::IServiceCreateExpectations<T, TReturn>.Handler3
							{
								@index = @index,
								@value = @value,
							};
							
							if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(@handler); }
							else { this.Expectations.handlers3.Add(@handler); }
							return new(@handler);
						}
						private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
					}
					
					internal IndexerExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
						(this.Getters, this.Setters) = (new(expectations), new(expectations));
					
					internal global::IServiceCreateExpectations<T, TReturn>.IndexerExpectations.IndexerGetterExpectations Getters { get; }
					internal global::IServiceCreateExpectations<T, TReturn>.IndexerExpectations.IndexerSetterExpectations Setters { get; }
				}
				
				internal global::IServiceCreateExpectations<T, TReturn>.PropertyExpectations Properties { get; }
				internal global::IServiceCreateExpectations<T, TReturn>.IndexerExpectations Indexers { get; }
				
				internal IServiceCreateExpectations() =>
					(this.Properties, this.Indexers) = (new(this), new(this));
				
				internal global::IService<T, TReturn> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IServiceCreateExpectations<T, TReturn>.Handler0, global::System.Func<T>, T>, IAdornmentsForIService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IServiceCreateExpectations<T, TReturn>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IServiceCreateExpectations<T, TReturn>.Handler1, global::System.Action<T>>, IAdornmentsForIService<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IServiceCreateExpectations<T, TReturn>.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IServiceCreateExpectations<T, TReturn>.Handler2, global::System.Func<TReturn, TReturn>, TReturn>, IAdornmentsForIService<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IServiceCreateExpectations<T, TReturn>.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::IServiceCreateExpectations<T, TReturn>.Handler3, global::System.Action<TReturn, TReturn>>, IAdornmentsForIService<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::IServiceCreateExpectations<T, TReturn>.Handler3 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT, TReturn_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithConstraintsAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(IService<,>))]
			
			#nullable enable

			public interface IService<T, TReturn>
				where T : class
				where TReturn : struct
			{
				TReturn Service(T data);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceCreateExpectations<T, TReturn>
				: global::Rocks.Expectations
				where T : class
				where TReturn : struct
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<T, TReturn>, TReturn>
				{
					public global::Rocks.Argument<T> @data { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T, TReturn>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IService<T, TReturn>
				{
					public Mock(global::IServiceCreateExpectations<T, TReturn> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public TReturn Service(T @data)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@data.IsValid(@data!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@data!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IServiceCreateExpectations<T, TReturn> expectations) =>
						this.Expectations = expectations;
					
					internal global::IServiceCreateExpectations<T, TReturn>.Adornments.AdornmentsForHandler0 Service(global::Rocks.Argument<T> @data)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@data);
						
						var @handler = new global::IServiceCreateExpectations<T, TReturn>.Handler0
						{
							@data = @data,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IServiceCreateExpectations<T, TReturn> Expectations { get; }
				}
				
				internal global::IServiceCreateExpectations<T, TReturn>.MethodExpectations Methods { get; }
				
				internal IServiceCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IService<T, TReturn> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IServiceCreateExpectations<T, TReturn>.Handler0, global::System.Func<T, TReturn>, TReturn>, IAdornmentsForIService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IServiceCreateExpectations<T, TReturn>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT, TReturn_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithConstraintsAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockMake(typeof(IService<,>))]
			
			#nullable enable

			public interface IService<T, TReturn>
				where T : class
				where TReturn : struct
			{
				TReturn Service(T data);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceMakeExpectations<T, TReturn>
				where T : class
				where TReturn : struct
			{
				internal global::IService<T, TReturn> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IService<T, TReturn>
				{
					public Mock()
					{
					}
					
					public TReturn Service(T @data)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IServiceT, TReturn_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithMultipleCollisionsAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Linq.Expressions;
						
			[assembly: RockCreate(typeof(IHasTypeConverterOptions<,>))]
			
			#nullable enable

			public interface IHasMapOptions<TClass, TMember> { }

			public interface IHasMap<TClass>
			{
				IHasMapOptions<TClass, TMember> Map<TMember>(Expression<Func<TClass, TMember>> expression, bool useExistingMap = true);
			}

			public interface IHasTypeConverterOptions<TClass, TMember>
				: IHasMap<TClass>
			{ }
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IHasTypeConverterOptionsCreateExpectations<TClass, TMember>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0<TMember1>
					: global::Rocks.Handler<global::System.Func<global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>>, bool, global::IHasMapOptions<TClass, TMember1>>, global::IHasMapOptions<TClass, TMember1>>
				{
					public global::Rocks.Argument<global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>>> @expression { get; set; }
					public global::Rocks.Argument<bool> @useExistingMap { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHasTypeConverterOptions<TClass, TMember>
				{
					public Mock(global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public global::IHasMapOptions<TClass, TMember1> Map<TMember1>(global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>> @expression, bool @useExistingMap = true)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers0)
							{
								if (@genericHandler is global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Handler0<TMember1> @handler)
								{
									if (@handler.@expression.IsValid(@expression!) &&
										@handler.@useExistingMap.IsValid(@useExistingMap!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@expression!, @useExistingMap!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember> expectations) =>
						this.Expectations = expectations;
					
					internal global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Adornments.AdornmentsForHandler0<TMember1> Map<TMember1>(global::Rocks.Argument<global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>>> @expression, global::Rocks.Argument<bool> @useExistingMap)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@expression);
						global::System.ArgumentNullException.ThrowIfNull(@useExistingMap);
						
						var @handler = new global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Handler0<TMember1>
						{
							@expression = @expression,
							@useExistingMap = @useExistingMap.Transform(true),
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					internal global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Adornments.AdornmentsForHandler0<TMember1> Map<TMember1>(global::Rocks.Argument<global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>>> @expression, bool @useExistingMap = true) =>
						this.Map<TMember1>(@expression, global::Rocks.Arg.Is(@useExistingMap));
					
					private global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember> Expectations { get; }
				}
				
				internal global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.MethodExpectations Methods { get; }
				
				internal IHasTypeConverterOptionsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IHasTypeConverterOptions<TClass, TMember> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHasTypeConverterOptions<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHasTypeConverterOptions<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0<TMember1>
						: global::Rocks.Adornments<AdornmentsForHandler0<TMember1>, global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Handler0<TMember1>, global::System.Func<global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>>, bool, global::IHasMapOptions<TClass, TMember1>>, global::IHasMapOptions<TClass, TMember1>>, IAdornmentsForIHasTypeConverterOptions<AdornmentsForHandler0<TMember1>>
					{
						public AdornmentsForHandler0(global::IHasTypeConverterOptionsCreateExpectations<TClass, TMember>.Handler0<TMember1> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IHasTypeConverterOptionsTClass, TMember_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithMultipleCollisionsAsync()
	{
		var code =
		  """
			using Rocks;
			using System;
			using System.Linq.Expressions;
						
			[assembly: RockMake(typeof(IHasTypeConverterOptions<,>))]
			
			#nullable enable

			public interface IHasMapOptions<TClass, TMember> { }
			
			public interface IHasMap<TClass>
			{
				IHasMapOptions<TClass, TMember> Map<TMember>(Expression<Func<TClass, TMember>> expression, bool useExistingMap = true);
			}
			
			public interface IHasTypeConverterOptions<TClass, TMember>
				: IHasMap<TClass>
			{ }
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IHasTypeConverterOptionsMakeExpectations<TClass, TMember>
			{
				internal global::IHasTypeConverterOptions<TClass, TMember> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IHasTypeConverterOptions<TClass, TMember>
				{
					public Mock()
					{
					}
					
					public global::IHasMapOptions<TClass, TMember1> Map<TMember1>(global::System.Linq.Expressions.Expression<global::System.Func<TClass, TMember1>> @expression, bool @useExistingMap = true)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IHasTypeConverterOptionsTClass, TMember_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithNameCollisionsInTypeParametersAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Threading.Tasks;
						
			[assembly: RockCreate(typeof(IExceptionConsumeContext<>))]
			
			#nullable enable

			public interface IStory
			{
				string GetContent();
			}

			public interface IContext
			{
				Task RespondAsync<T>(T message);
			}

			public interface IConsumeContext<out TStory>
				: IContext
				where TStory : class, IStory
			{
				Task SetCompleted();
			}

			public interface IExceptionConsumeContext<out T>
				: IConsumeContext<T>
				where T : class, IStory
			{
				Exception Exception { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IExceptionConsumeContextCreateExpectations<T>
				: global::Rocks.Expectations
				where T : class, global::IStory
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>
				{ }
				private global::Rocks.Handlers<global::IExceptionConsumeContextCreateExpectations<T>.Handler0>? @handlers0;
				internal sealed class Handler1<T1>
					: global::Rocks.Handler<global::System.Func<T1, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>
				{
					public global::Rocks.Argument<T1> @message { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<global::System.Exception>, global::System.Exception>
				{ }
				private global::Rocks.Handlers<global::IExceptionConsumeContextCreateExpectations<T>.Handler2>? @handlers2;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IExceptionConsumeContext<T>
				{
					public Mock(global::IExceptionConsumeContextCreateExpectations<T> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public global::System.Threading.Tasks.Task SetCompleted()
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @handler = this.Expectations.handlers0.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public global::System.Threading.Tasks.Task RespondAsync<T1>(T1 @message)
					{
						if (this.Expectations.handlers1 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers1)
							{
								if (@genericHandler is global::IExceptionConsumeContextCreateExpectations<T>.Handler1<T1> @handler)
								{
									if (@handler.@message.IsValid(@message!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@message!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(1)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)}");
					}
					
					[global::Rocks.MemberIdentifier(2, global::Rocks.PropertyAccessor.Get)]
					public global::System.Exception Exception
					{
						get
						{
							if (this.Expectations.handlers2 is not null)
							{
								var @handler = this.Expectations.handlers2.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(2)})");
						}
					}
					
					private global::IExceptionConsumeContextCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IExceptionConsumeContextCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::IExceptionConsumeContextCreateExpectations<T>.Adornments.AdornmentsForHandler0 SetCompleted()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IExceptionConsumeContextCreateExpectations<T>.Handler0();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					internal global::IExceptionConsumeContextCreateExpectations<T>.Adornments.AdornmentsForHandler1<T1> RespondAsync<T1>(global::Rocks.Argument<T1> @message)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@message);
						
						var @handler = new global::IExceptionConsumeContextCreateExpectations<T>.Handler1<T1>
						{
							@message = @message,
						};
						
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(@handler); }
						else { this.Expectations.handlers1.Add(@handler); }
						return new(@handler);
					}
					
					private global::IExceptionConsumeContextCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IExceptionConsumeContextCreateExpectations<T> expectations) =>
							this.Expectations = expectations;
						
						internal global::IExceptionConsumeContextCreateExpectations<T>.Adornments.AdornmentsForHandler2 Exception()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IExceptionConsumeContextCreateExpectations<T>.Handler2();
							if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
							else { this.Expectations.handlers2.Add(handler); }
							return new(handler);
						}
						private global::IExceptionConsumeContextCreateExpectations<T> Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IExceptionConsumeContextCreateExpectations<T> expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IExceptionConsumeContextCreateExpectations<T>.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				
				internal global::IExceptionConsumeContextCreateExpectations<T>.MethodExpectations Methods { get; }
				internal global::IExceptionConsumeContextCreateExpectations<T>.PropertyExpectations Properties { get; }
				
				internal IExceptionConsumeContextCreateExpectations() =>
					(this.Methods, this.Properties) = (new(this), new(this));
				
				internal global::IExceptionConsumeContext<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIExceptionConsumeContext<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIExceptionConsumeContext<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IExceptionConsumeContextCreateExpectations<T>.Handler0, global::System.Func<global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>, IAdornmentsForIExceptionConsumeContext<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IExceptionConsumeContextCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1<T1>
						: global::Rocks.Adornments<AdornmentsForHandler1<T1>, global::IExceptionConsumeContextCreateExpectations<T>.Handler1<T1>, global::System.Func<T1, global::System.Threading.Tasks.Task>, global::System.Threading.Tasks.Task>, IAdornmentsForIExceptionConsumeContext<AdornmentsForHandler1<T1>>
					{
						public AdornmentsForHandler1(global::IExceptionConsumeContextCreateExpectations<T>.Handler1<T1> handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IExceptionConsumeContextCreateExpectations<T>.Handler2, global::System.Func<global::System.Exception>, global::System.Exception>, IAdornmentsForIExceptionConsumeContext<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IExceptionConsumeContextCreateExpectations<T>.Handler2 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IExceptionConsumeContextT_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithNameCollisionsInTypeParametersAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Threading.Tasks;
						
			[assembly: RockMake(typeof(IExceptionConsumeContext<>))]
			
			#nullable enable

			public interface IStory
			{
				string GetContent();
			}

			public interface IContext
			{
				Task RespondAsync<T>(T message);
			}

			public interface IConsumeContext<out TStory>
				: IContext
				where TStory : class, IStory
			{
				Task SetCompleted();
			}

			public interface IExceptionConsumeContext<out T>
				: IConsumeContext<T>
				where T : class, IStory
			{
				Exception Exception { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IExceptionConsumeContextMakeExpectations<T>
				where T : class, global::IStory
			{
				internal global::IExceptionConsumeContext<T> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IExceptionConsumeContext<T>
				{
					public Mock()
					{
					}
					
					public global::System.Threading.Tasks.Task SetCompleted()
					{
						return global::System.Threading.Tasks.Task.CompletedTask;
					}
					public global::System.Threading.Tasks.Task RespondAsync<T1>(T1 @message)
					{
						return global::System.Threading.Tasks.Task.CompletedTask;
					}
					public global::System.Exception Exception
					{
						get => default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IExceptionConsumeContextT_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenConstraintsAndTypeCollisionExistAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: Rock(typeof(IService<>), BuildType.Create | BuildType.Make)]
			
			#nullable enable

			public interface IValues
			{
				string Obtain<T>(T key) where T : class;
			}

			public interface IService<T>
				: IValues
			{
				string Service(T data);
			}
			""";

		var createGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceCreateExpectations<T>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<T, string>, string>
				{
					public global::Rocks.Argument<T> @data { get; set; }
				}
				private global::Rocks.Handlers<global::IServiceCreateExpectations<T>.Handler0>? @handlers0;
				internal sealed class Handler1<T1>
					: global::Rocks.Handler<global::System.Func<T1, string>, string>
					where T1 : class
				{
					public global::Rocks.Argument<T1> @key { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers1;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IService<T>
				{
					public Mock(global::IServiceCreateExpectations<T> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public string Service(T @data)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@data.IsValid(@data!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@data!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public string Obtain<T1>(T1 @key)
						where T1 : class
					{
						if (this.Expectations.handlers1 is not null)
						{
							foreach (var @genericHandler in this.Expectations.handlers1)
							{
								if (@genericHandler is global::IServiceCreateExpectations<T>.Handler1<T1> @handler)
								{
									if (@handler.@key.IsValid(@key!))
									{
										@handler.CallCount++;
										var @result = @handler.Callback is not null ?
											@handler.Callback(@key!) : @handler.ReturnValue;
										return @result!;
									}
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(1)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)}");
					}
					
					private global::IServiceCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IServiceCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::IServiceCreateExpectations<T>.Adornments.AdornmentsForHandler0 Service(global::Rocks.Argument<T> @data)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@data);
						
						var @handler = new global::IServiceCreateExpectations<T>.Handler0
						{
							@data = @data,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal global::IServiceCreateExpectations<T>.Adornments.AdornmentsForHandler1<T1> Obtain<T1>(global::Rocks.Argument<T1> @key) where T1 : class
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@key);
						
						var @handler = new global::IServiceCreateExpectations<T>.Handler1<T1>
						{
							@key = @key,
						};
						
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(@handler); }
						else { this.Expectations.handlers1.Add(@handler); }
						return new(@handler);
					}
					
					private global::IServiceCreateExpectations<T> Expectations { get; }
				}
				
				internal global::IServiceCreateExpectations<T>.MethodExpectations Methods { get; }
				
				internal IServiceCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IService<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIService<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIService<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IServiceCreateExpectations<T>.Handler0, global::System.Func<T, string>, string>, IAdornmentsForIService<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IServiceCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1<T1>
						: global::Rocks.Adornments<AdornmentsForHandler1<T1>, global::IServiceCreateExpectations<T>.Handler1<T1>, global::System.Func<T1, string>, string>, IAdornmentsForIService<AdornmentsForHandler1<T1>> where T1 : class
					{
						public AdornmentsForHandler1(global::IServiceCreateExpectations<T>.Handler1<T1> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		var makeGeneratedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IServiceMakeExpectations<T>
			{
				internal global::IService<T> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IService<T>
				{
					public Mock()
					{
					}
					
					public string Service(T @data)
					{
						return default!;
					}
					public string Obtain<T1>(T1 @key)
						where T1 : class
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[
				(typeof(RockGenerator), "IServiceT_Rock_Create.g.cs", createGeneratedCode),
				(typeof(RockGenerator), "IServiceT_Rock_Make.g.cs", makeGeneratedCode)
			],
			[]);
	}

	[Test]
	public static async Task CreateWithRefStructAsync()
	{
		var code =
		  """
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(IPixelOperations<>))]
			
			#nullable enable

			public interface IPixelOperations<TPixel> where TPixel : unmanaged
			{
				void Destructive(Span<TPixel> destinationPixels);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IPixelOperationsCreateExpectations<TPixel>
				: global::Rocks.Expectations
				where TPixel : unmanaged
			{
				internal static class Projections
				{
					internal delegate void Callback_6880507936518113545154238437489757677796400069(global::System.Span<TPixel> @destinationPixels);
					internal delegate bool ArgumentEvaluationForSpan<TPixel1>(global::System.Span<TPixel1> @value);
					
					internal sealed class ArgumentForSpan<TPixel1>
						: global::Rocks.Argument
					{
						private readonly global::IPixelOperationsCreateExpectations<TPixel>.Projections.ArgumentEvaluationForSpan<TPixel1>? evaluation;
						private readonly global::Rocks.ValidationState validation;
						
						internal ArgumentForSpan() => this.validation = global::Rocks.ValidationState.None;
						
						internal ArgumentForSpan(global::IPixelOperationsCreateExpectations<TPixel>.Projections.ArgumentEvaluationForSpan<TPixel1> @evaluation)
						{
							this.evaluation = @evaluation;
							this.validation = global::Rocks.ValidationState.Evaluation;
						}
						
						public bool IsValid(global::System.Span<TPixel1> @value) =>
							this.validation switch
							{
								global::Rocks.ValidationState.None => true,
								global::Rocks.ValidationState.Evaluation => this.evaluation!(@value),
								_ => throw new global::System.NotSupportedException("Invalid validation state."),
							};
					}
				}
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::IPixelOperationsCreateExpectations<TPixel>.Projections.Callback_6880507936518113545154238437489757677796400069>
				{
					public global::IPixelOperationsCreateExpectations<TPixel>.Projections.ArgumentForSpan<TPixel> @destinationPixels { get; set; }
				}
				private global::Rocks.Handlers<global::IPixelOperationsCreateExpectations<TPixel>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IPixelOperations<TPixel>
				{
					public Mock(global::IPixelOperationsCreateExpectations<TPixel> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Destructive(global::System.Span<TPixel> @destinationPixels)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@destinationPixels.IsValid(@destinationPixels!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@destinationPixels!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IPixelOperationsCreateExpectations<TPixel> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IPixelOperationsCreateExpectations<TPixel> expectations) =>
						this.Expectations = expectations;
					
					internal global::IPixelOperationsCreateExpectations<TPixel>.Adornments.AdornmentsForHandler0 Destructive(global::IPixelOperationsCreateExpectations<TPixel>.Projections.ArgumentForSpan<TPixel> @destinationPixels)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@destinationPixels);
						
						var @handler = new global::IPixelOperationsCreateExpectations<TPixel>.Handler0
						{
							@destinationPixels = @destinationPixels,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IPixelOperationsCreateExpectations<TPixel> Expectations { get; }
				}
				
				internal global::IPixelOperationsCreateExpectations<TPixel>.MethodExpectations Methods { get; }
				
				internal IPixelOperationsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IPixelOperations<TPixel> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIPixelOperations<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIPixelOperations<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IPixelOperationsCreateExpectations<TPixel>.Handler0, global::IPixelOperationsCreateExpectations<TPixel>.Projections.Callback_6880507936518113545154238437489757677796400069>, IAdornmentsForIPixelOperations<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IPixelOperationsCreateExpectations<TPixel>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IPixelOperationsTPixel_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithRefStructAsync()
	{
		var code =
		  """
			using Rocks;
			using System;
			
			[assembly: RockMake(typeof(IPixelOperations<>))]
			
			#nullable enable

			public interface IPixelOperations<TPixel> where TPixel : unmanaged
			{
				void Destructive(Span<TPixel> destinationPixels);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IPixelOperationsMakeExpectations<TPixel>
				where TPixel : unmanaged
			{
				internal global::IPixelOperations<TPixel> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IPixelOperations<TPixel>
				{
					public Mock()
					{
					}
					
					public void Destructive(global::System.Span<TPixel> @destinationPixels)
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IPixelOperationsTPixel_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithNullableReferenceAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(INotification))]
			
			#nullable enable

			public interface INotification
			{
				void Similar<T>(string? key, T? value) where T : struct, Enum;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class INotificationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0<T>
					: global::Rocks.Handler<global::System.Action<string?, T?>>
					where T : struct, global::System.Enum
				{
					public global::Rocks.Argument<string?> @key { get; set; }
					public global::Rocks.Argument<T?> @value { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::INotification
				{
					public Mock(global::INotificationCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Similar<T>(string? @key, T? @value)
						where T : struct, global::System.Enum
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @genericHandler in this.Expectations.handlers0)
							{
								if (@genericHandler is global::INotificationCreateExpectations.Handler0<T> @handler)
								{
									if (@handler.@key.IsValid(@key!) &&
										@handler.@value.IsValid(@value!))
									{
										@foundMatch = true;
										@handler.CallCount++;
										@handler.Callback?.Invoke(@key!, @value!);
										break;
									}
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::INotificationCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::INotificationCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::INotificationCreateExpectations.Adornments.AdornmentsForHandler0<T> Similar<T>(global::Rocks.Argument<string?> @key, global::Rocks.Argument<T?> @value) where T : struct, global::System.Enum
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@key);
						global::System.ArgumentNullException.ThrowIfNull(@value);
						
						var @handler = new global::INotificationCreateExpectations.Handler0<T>
						{
							@key = @key,
							@value = @value,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::INotificationCreateExpectations Expectations { get; }
				}
				
				internal global::INotificationCreateExpectations.MethodExpectations Methods { get; }
				
				internal INotificationCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::INotification Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForINotification<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForINotification<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0<T>
						: global::Rocks.Adornments<AdornmentsForHandler0<T>, global::INotificationCreateExpectations.Handler0<T>, global::System.Action<string?, T?>>, IAdornmentsForINotification<AdornmentsForHandler0<T>> where T : struct, global::System.Enum
					{
						public AdornmentsForHandler0(global::INotificationCreateExpectations.Handler0<T> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "INotification_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithNullableReferenceAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockMake(typeof(INotification))]
			
			#nullable enable

			public interface INotification
			{
				void Similar<T>(string? key, T? value) where T : struct, Enum;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class INotificationMakeExpectations
			{
				internal global::INotification Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::INotification
				{
					public Mock()
					{
					}
					
					public void Similar<T>(string? @key, T? @value)
						where T : struct, global::System.Enum
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "INotification_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithNullableReferenceInReturnAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Collections.Generic;
						
			[assembly: RockCreate(typeof(IReaderWriter<,,>))]
			
			#nullable enable

			public sealed class Manager { }

			public interface IReaderWriter<TCollection, TConcreteCollection, TElement>
				where TCollection : IEnumerable<TElement?> where TElement : struct
			{
				IEnumerable<TElement?> FromJsonTyped(ref Manager manager, object? existingObject = null);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>
				: global::Rocks.Expectations
				where TCollection : global::System.Collections.Generic.IEnumerable<TElement?>
				where TElement : struct
			{
				internal static class Projections
				{
					internal delegate global::System.Collections.Generic.IEnumerable<TElement?> Callback_301394992348083256002899599784820901538420162609(ref global::Manager @manager, object? @existingObject);
				}
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Projections.Callback_301394992348083256002899599784820901538420162609, global::System.Collections.Generic.IEnumerable<TElement?>>
				{
					public global::Rocks.Argument<global::Manager> @manager { get; set; }
					public global::Rocks.Argument<object?> @existingObject { get; set; }
				}
				private global::Rocks.Handlers<global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IReaderWriter<TCollection, TConcreteCollection, TElement>
				{
					public Mock(global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public global::System.Collections.Generic.IEnumerable<TElement?> FromJsonTyped(ref global::Manager @manager, object? @existingObject = null)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@manager.IsValid(@manager!) &&
									@handler.@existingObject.IsValid(@existingObject!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(ref @manager!, @existingObject!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement> expectations) =>
						this.Expectations = expectations;
					
					internal global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Adornments.AdornmentsForHandler0 FromJsonTyped(global::Rocks.Argument<global::Manager> @manager, global::Rocks.Argument<object?> @existingObject)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@manager);
						global::System.ArgumentNullException.ThrowIfNull(@existingObject);
						
						var @handler = new global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Handler0
						{
							@manager = @manager,
							@existingObject = @existingObject.Transform(null),
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					internal global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Adornments.AdornmentsForHandler0 FromJsonTyped(global::Rocks.Argument<global::Manager> @manager, object? @existingObject = null) =>
						this.FromJsonTyped(@manager, global::Rocks.Arg.Is(@existingObject));
					
					private global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement> Expectations { get; }
				}
				
				internal global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.MethodExpectations Methods { get; }
				
				internal IReaderWriterCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IReaderWriter<TCollection, TConcreteCollection, TElement> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIReaderWriter<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIReaderWriter<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Handler0, global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Projections.Callback_301394992348083256002899599784820901538420162609, global::System.Collections.Generic.IEnumerable<TElement?>>, IAdornmentsForIReaderWriter<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IReaderWriterCreateExpectations<TCollection, TConcreteCollection, TElement>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IReaderWriterTCollection, TConcreteCollection, TElement_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithNullableReferenceInReturnAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Collections.Generic;
						
			[assembly: RockMake(typeof(IReaderWriter<,,>))]
			
			#nullable enable

			public sealed class Manager { }

			public interface IReaderWriter<TCollection, TConcreteCollection, TElement>
				where TCollection : IEnumerable<TElement?> where TElement : struct
			{
				IEnumerable<TElement?> FromJsonTyped(ref Manager manager, object? existingObject = null);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IReaderWriterMakeExpectations<TCollection, TConcreteCollection, TElement>
				where TCollection : global::System.Collections.Generic.IEnumerable<TElement?>
				where TElement : struct
			{
				internal global::IReaderWriter<TCollection, TConcreteCollection, TElement> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IReaderWriter<TCollection, TConcreteCollection, TElement>
				{
					public Mock()
					{
					}
					
					public global::System.Collections.Generic.IEnumerable<TElement?> FromJsonTyped(ref global::Manager @manager, object? @existingObject = null)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IReaderWriterTCollection, TConcreteCollection, TElement_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithGenericNullableReferenceAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockCreate(typeof(INotification<>))]
			
			#nullable enable

			public interface INotification<T>
			{
				bool Similar(INotification<T>? other);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class INotificationCreateExpectations<T>
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::INotification<T>?, bool>, bool>
				{
					public global::Rocks.Argument<global::INotification<T>?> @other { get; set; }
				}
				private global::Rocks.Handlers<global::INotificationCreateExpectations<T>.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::INotification<T>
				{
					public Mock(global::INotificationCreateExpectations<T> @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public bool Similar(global::INotification<T>? @other)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@other.IsValid(@other!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@other!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::INotificationCreateExpectations<T> Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::INotificationCreateExpectations<T> expectations) =>
						this.Expectations = expectations;
					
					internal global::INotificationCreateExpectations<T>.Adornments.AdornmentsForHandler0 Similar(global::Rocks.Argument<global::INotification<T>?> @other)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@other);
						
						var @handler = new global::INotificationCreateExpectations<T>.Handler0
						{
							@other = @other,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::INotificationCreateExpectations<T> Expectations { get; }
				}
				
				internal global::INotificationCreateExpectations<T>.MethodExpectations Methods { get; }
				
				internal INotificationCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::INotification<T> Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForINotification<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForINotification<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::INotificationCreateExpectations<T>.Handler0, global::System.Func<global::INotification<T>?, bool>, bool>, IAdornmentsForINotification<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::INotificationCreateExpectations<T>.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "INotificationT_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithGenericNullableReferenceAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			[assembly: RockMake(typeof(INotification<>))]
			
			#nullable enable

			public interface INotification<T>
			{
				bool Similar(INotification<T>? other);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class INotificationMakeExpectations<T>
			{
				internal global::INotification<T> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::INotification<T>
				{
					public Mock()
					{
					}
					
					public bool Similar(global::INotification<T>? @other)
					{
						return default!;
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "INotificationT_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithMultipleNullableAnnotationsOnTypeAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Collections.Generic;
						
			[assembly: RockCreate(typeof(IWriter))]
			
			#nullable enable

			public interface IWriter
			{
				void WriteCollectionOfEnumValues<T>(string? key, IEnumerable<T?>? values) where T : struct, Enum;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IWriterCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0<T>
					: global::Rocks.Handler<global::System.Action<string?, global::System.Collections.Generic.IEnumerable<T?>?>>
					where T : struct, global::System.Enum
				{
					public global::Rocks.Argument<string?> @key { get; set; }
					public global::Rocks.Argument<global::System.Collections.Generic.IEnumerable<T?>?> @values { get; set; }
				}
				private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IWriter
				{
					public Mock(global::IWriterCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void WriteCollectionOfEnumValues<T>(string? @key, global::System.Collections.Generic.IEnumerable<T?>? @values)
						where T : struct, global::System.Enum
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @genericHandler in this.Expectations.handlers0)
							{
								if (@genericHandler is global::IWriterCreateExpectations.Handler0<T> @handler)
								{
									if (@handler.@key.IsValid(@key!) &&
										@handler.@values.IsValid(@values!))
									{
										@foundMatch = true;
										@handler.CallCount++;
										@handler.Callback?.Invoke(@key!, @values!);
										break;
									}
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IWriterCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IWriterCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IWriterCreateExpectations.Adornments.AdornmentsForHandler0<T> WriteCollectionOfEnumValues<T>(global::Rocks.Argument<string?> @key, global::Rocks.Argument<global::System.Collections.Generic.IEnumerable<T?>?> @values) where T : struct, global::System.Enum
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@key);
						global::System.ArgumentNullException.ThrowIfNull(@values);
						
						var @handler = new global::IWriterCreateExpectations.Handler0<T>
						{
							@key = @key,
							@values = @values,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IWriterCreateExpectations Expectations { get; }
				}
				
				internal global::IWriterCreateExpectations.MethodExpectations Methods { get; }
				
				internal IWriterCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IWriter Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIWriter<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIWriter<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0<T>
						: global::Rocks.Adornments<AdornmentsForHandler0<T>, global::IWriterCreateExpectations.Handler0<T>, global::System.Action<string?, global::System.Collections.Generic.IEnumerable<T?>?>>, IAdornmentsForIWriter<AdornmentsForHandler0<T>> where T : struct, global::System.Enum
					{
						public AdornmentsForHandler0(global::IWriterCreateExpectations.Handler0<T> handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IWriter_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task MakeWithMultipleNullableAnnotationsOnTypeAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.Collections.Generic;
						
			[assembly: RockMake(typeof(IWriter))]
			
			#nullable enable

			public interface IWriter
			{
				void WriteCollectionOfEnumValues<T>(string? key, IEnumerable<T?>? values) where T : struct, Enum;
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
			internal sealed class IWriterMakeExpectations
			{
				internal global::IWriter Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::IWriter
				{
					public Mock()
					{
					}
					
					public void WriteCollectionOfEnumValues<T>(string? @key, global::System.Collections.Generic.IEnumerable<T?>? @values)
						where T : struct, global::System.Enum
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockGenerator>(code,
			[(typeof(RockGenerator), "IWriter_Rock_Make.g.cs", generatedCode)],
			[]);
	}
}