using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class NamingGeneratorTests
{
	[Test]
	public static async Task CreateWithDuplicateTypeNamesAsync()
	{
		var references = Shared.References.Value
			.Cast<MetadataReference>()
			.ToList();

		var firstSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}

			public interface IUseSameNames
			{
				void Use(SameNamespace.SameType value);
			}			
			""";
		var firstSourceSyntaxTree = CSharpSyntaxTree.ParseText(firstSource);
		var firstSourceCompilation = CSharpCompilation.Create("first", new SyntaxTree[] { firstSourceSyntaxTree },
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var firstSourceReference = firstSourceCompilation.ToMetadataReference()!;
		firstSourceReference = firstSourceReference.WithAliases(["First"]);

		var secondSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}
			""";
		var secondSourceSyntaxTree = CSharpSyntaxTree.ParseText(secondSource);
		var secondSourceCompilation = CSharpCompilation.Create("second", new SyntaxTree[] { secondSourceSyntaxTree },
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var secondSourceReference = secondSourceCompilation.ToMetadataReference()!;

		var code =
			"""
			extern alias First;

			using Rocks;

			[assembly: RockCreate<First.IUseSameNames>]
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			extern alias First;
			
			internal sealed class IUseSameNamesCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<First::SameNamespace.SameType>>
				{
					public global::Rocks.Argument<First::SameNamespace.SameType> @value { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IUseSameNamesCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: First::IUseSameNames
				{
					public Mock(global::IUseSameNamesCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "void Use(First::SameNamespace.SameType @value)")]
					public void Use(First::SameNamespace.SameType @value)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@value.IsValid(@value!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@value!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Use(First::SameNamespace.SameType @value)");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Use(First::SameNamespace.SameType @value)");
						}
					}
					
					private global::IUseSameNamesCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUseSameNamesCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IUseSameNamesCreateExpectations.Handler0, global::System.Action<First::SameNamespace.SameType>> Use(global::Rocks.Argument<First::SameNamespace.SameType> @value)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@value);
						
						var handler = new global::IUseSameNamesCreateExpectations.Handler0
						{
							@value = @value,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					private global::IUseSameNamesCreateExpectations Expectations { get; }
				}
				
				internal global::IUseSameNamesCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUseSameNamesCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal First::IUseSameNames Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		references.AddRange([firstSourceReference, secondSourceReference]);

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "FirstIUseSameNames_Rock_Create.g.cs", generatedCode) },
			[],
			additionalReferences: references).ConfigureAwait(false);
	}

	[Test]
	public static async Task MakeWithDuplicateTypeNamesAsync()
	{
		var references = Shared.References.Value
			.Cast<MetadataReference>()
			.ToList();

		var firstSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}

			public interface IUseSameNames
			{
				void Use(SameNamespace.SameType value);
			}			
			""";
		var firstSourceSyntaxTree = CSharpSyntaxTree.ParseText(firstSource);
		var firstSourceCompilation = CSharpCompilation.Create("first", new SyntaxTree[] { firstSourceSyntaxTree },
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var firstSourceReference = firstSourceCompilation.ToMetadataReference()!;
		firstSourceReference = firstSourceReference.WithAliases(["First"]);

		var secondSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}
			""";
		var secondSourceSyntaxTree = CSharpSyntaxTree.ParseText(secondSource);
		var secondSourceCompilation = CSharpCompilation.Create("second", new SyntaxTree[] { secondSourceSyntaxTree },
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var secondSourceReference = secondSourceCompilation.ToMetadataReference()!;

		var code =
			"""
			extern alias First;

			using Rocks;

			[assembly: RockMake<First.IUseSameNames>]
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			extern alias First;
			
			internal sealed class IUseSameNamesMakeExpectations
			{
				internal First::IUseSameNames Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: First::IUseSameNames
				{
					public Mock()
					{
					}
					
					public void Use(First::SameNamespace.SameType @value)
					{
					}
				}
			}
			
			""";

		references.AddRange([firstSourceReference, secondSourceReference]);

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "FirstIUseSameNames_Rock_Make.g.cs", generatedCode) },
			[],
			additionalReferences: references).ConfigureAwait(false);
	}

	[Test]
	public static async Task MakeWithGenericReturnsAsync()
	{
		var code =
			"""
			using Rocks;
			using System.Threading.Tasks;

			[assembly: RockMake<DbSet<object>>]

			public class EntityEntry<TEntity>
				where TEntity : class { }

			public class DbSet<TEntity>
				where TEntity : class
			{
				public virtual ValueTask<EntityEntry<TEntity>> AddAsync() =>
					new();
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class DbSetOfobjectMakeExpectations
			{
				internal global::DbSet<object> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::DbSet<object>
				{
					public Mock()
					{
					}
					
					public override bool Equals(object? @obj)
					{
						return default!;
					}
					public override int GetHashCode()
					{
						return default!;
					}
					public override string? ToString()
					{
						return default!;
					}
					public override global::System.Threading.Tasks.ValueTask<global::EntityEntry<object>> AddAsync()
					{
						return new global::System.Threading.Tasks.ValueTask<global::EntityEntry<object>>(default(global::EntityEntry<object>)!);
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "DbSetobject_Rock_Make.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenNonVirtualMembersAreNeededAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.IO;

			[assembly: RockCreate<IHaveDelegate>]

			public class IHaveDelegate
			{
				public Func<Stream, Stream> Processor { get; init; }   
				public virtual void Foo() { }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IHaveDelegateCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IHaveDelegateCreateExpectations.Handler0>? @handlers0;
				private global::System.Collections.Generic.List<global::IHaveDelegateCreateExpectations.Handler1>? @handlers1;
				private global::System.Collections.Generic.List<global::IHaveDelegateCreateExpectations.Handler2>? @handlers2;
				private global::System.Collections.Generic.List<global::IHaveDelegateCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1?.Count > 0) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2?.Count > 0) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3?.Count > 0) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveDelegate
				{
					public Mock(global::IHaveDelegateCreateExpectations @expectations, ConstructorProperties? @constructorProperties)
					{
						this.Expectations = @expectations;
						if (@constructorProperties is not null)
						{
							this.Processor = @constructorProperties.Processor!;
						}
					}
					
					[global::Rocks.MemberIdentifier(0, "bool Equals(object? @obj)")]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers match for bool Equals(object? @obj)");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1, "int GetHashCode()")]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1?.Count > 0)
						{
							var @handler = this.Expectations.handlers1[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2, "string? ToString()")]
					public override string? ToString()
					{
						if (this.Expectations.handlers2?.Count > 0)
						{
							var @handler = this.Expectations.handlers2[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3, "void Foo()")]
					public override void Foo()
					{
						if (this.Expectations.handlers3?.Count > 0)
						{
							var @handler = this.Expectations.handlers3[0];
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::IHaveDelegateCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveDelegateCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IHaveDelegateCreateExpectations.Handler0, global::System.Func<object?, bool>, bool> Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var handler = new global::IHaveDelegateCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::IHaveDelegateCreateExpectations.Handler1, global::System.Func<int>, int> GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(); }
						var handler = new global::IHaveDelegateCreateExpectations.Handler1();
						this.Expectations.handlers1.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::IHaveDelegateCreateExpectations.Handler2, global::System.Func<string?>, string?> ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(); }
						var handler = new global::IHaveDelegateCreateExpectations.Handler2();
						this.Expectations.handlers2.Add(handler);
						return new(handler);
					}
					
					internal global::Rocks.Adornments<global::IHaveDelegateCreateExpectations.Handler3, global::System.Action> Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(); }
						var handler = new global::IHaveDelegateCreateExpectations.Handler3();
						this.Expectations.handlers3.Add(handler);
						return new(handler);
					}
					
					private global::IHaveDelegateCreateExpectations Expectations { get; }
				}
				
				internal global::IHaveDelegateCreateExpectations.MethodExpectations Methods { get; }
				
				internal IHaveDelegateCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal sealed class ConstructorProperties
				{
					internal global::System.Func<global::System.IO.Stream, global::System.IO.Stream>? Processor { get; init; }
				}
				
				internal global::IHaveDelegate Instance(global::IHaveDelegateCreateExpectations.ConstructorProperties? @constructorProperties)
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @constructorProperties);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IHaveDelegate_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenNamesAreKeywordsAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IUseKeyword>]

			public interface IUseKeyword
			{
			    void Foo(string @namespace, string @event, string @property);   
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IUseKeywordCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<string, string, string>>
				{
					public global::Rocks.Argument<string> @namespace { get; set; }
					public global::Rocks.Argument<string> @event { get; set; }
					public global::Rocks.Argument<string> @property { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IUseKeywordCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUseKeyword
				{
					public Mock(global::IUseKeywordCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "void Foo(string @namespace, string @event, string @property)")]
					public void Foo(string @namespace, string @event, string @property)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@namespace.IsValid(@namespace!) &&
									@handler.@event.IsValid(@event!) &&
									@handler.@property.IsValid(@property!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@namespace!, @event!, @property!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Foo(string @namespace, string @event, string @property)");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Foo(string @namespace, string @event, string @property)");
						}
					}
					
					private global::IUseKeywordCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUseKeywordCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IUseKeywordCreateExpectations.Handler0, global::System.Action<string, string, string>> Foo(global::Rocks.Argument<string> @namespace, global::Rocks.Argument<string> @event, global::Rocks.Argument<string> @property)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@namespace);
						global::System.ArgumentNullException.ThrowIfNull(@event);
						global::System.ArgumentNullException.ThrowIfNull(@property);
						
						var handler = new global::IUseKeywordCreateExpectations.Handler0
						{
							@namespace = @namespace,
							@event = @event,
							@property = @property,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					private global::IUseKeywordCreateExpectations Expectations { get; }
				}
				
				internal global::IUseKeywordCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUseKeywordCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IUseKeyword Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";
			
		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IUseKeyword_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWithConstructorWithSelfNameAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<HaveNamingConflicts>]

			public class HaveNamingConflicts
			{
				public HaveNamingConflicts(string self, string expectations) { }
				public virtual void Foo() { }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class HaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::HaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				private global::System.Collections.Generic.List<global::HaveNamingConflictsCreateExpectations.Handler1>? @handlers1;
				private global::System.Collections.Generic.List<global::HaveNamingConflictsCreateExpectations.Handler2>? @handlers2;
				private global::System.Collections.Generic.List<global::HaveNamingConflictsCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1?.Count > 0) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2?.Count > 0) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3?.Count > 0) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::HaveNamingConflicts
				{
					public Mock(global::HaveNamingConflictsCreateExpectations @expectations1, string @self, string @expectations)
						: base(@self, @expectations)
					{
						this.Expectations = @expectations1;
					}
					
					[global::Rocks.MemberIdentifier(0, "bool Equals(object? @obj)")]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers match for bool Equals(object? @obj)");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1, "int GetHashCode()")]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1?.Count > 0)
						{
							var @handler = this.Expectations.handlers1[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2, "string? ToString()")]
					public override string? ToString()
					{
						if (this.Expectations.handlers2?.Count > 0)
						{
							var @handler = this.Expectations.handlers2[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3, "void Foo()")]
					public override void Foo()
					{
						if (this.Expectations.handlers3?.Count > 0)
						{
							var @handler = this.Expectations.handlers3[0];
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::HaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::HaveNamingConflictsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::HaveNamingConflictsCreateExpectations.Handler0, global::System.Func<object?, bool>, bool> Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::HaveNamingConflictsCreateExpectations.Handler1, global::System.Func<int>, int> GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(); }
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler1();
						this.Expectations.handlers1.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::HaveNamingConflictsCreateExpectations.Handler2, global::System.Func<string?>, string?> ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(); }
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler2();
						this.Expectations.handlers2.Add(handler);
						return new(handler);
					}
					
					internal global::Rocks.Adornments<global::HaveNamingConflictsCreateExpectations.Handler3, global::System.Action> Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(); }
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler3();
						this.Expectations.handlers3.Add(handler);
						return new(handler);
					}
					
					private global::HaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal global::HaveNamingConflictsCreateExpectations.MethodExpectations Methods { get; }
				
				internal HaveNamingConflictsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::HaveNamingConflicts Instance(string @self, string @expectations)
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @self, @expectations);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "HaveNamingConflicts_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenIndexerParameterNamesMatchVariablesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IHaveNamingConflicts>]

			public interface IHaveNamingConflicts
			{
				int this[string methodHandlers, string methodHandler, string result, string result2, string self] { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IHaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<string, string, string, string, string, int>, int>
				{
					public global::Rocks.Argument<string> @methodHandlers { get; set; }
					public global::Rocks.Argument<string> @methodHandler { get; set; }
					public global::Rocks.Argument<string> @result { get; set; }
					public global::Rocks.Argument<string> @result2 { get; set; }
					public global::Rocks.Argument<string> @self { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IHaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveNamingConflicts
				{
					public Mock(global::IHaveNamingConflictsCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "this[string @methodHandlers, string @methodHandler, string @result, string @result2, string @self]")]
					public int this[string @methodHandlers, string @methodHandler, string @result, string @result2, string @self]
					{
						get
						{
							if (this.Expectations.handlers0?.Count > 0)
							{
								foreach (var @handler in this.Expectations.handlers0)
								{
									if (@handler.@methodHandlers.IsValid(@methodHandlers!) &&
										@handler.@methodHandler.IsValid(@methodHandler!) &&
										@handler.@result.IsValid(@result!) &&
										@handler.@result2.IsValid(@result2!) &&
										@handler.@self.IsValid(@self!))
									{
										@handler.CallCount++;
										var @result1 = @handler.Callback is not null ?
											@handler.Callback(@methodHandlers!, @methodHandler!, @result!, @result2!, @self!) : @handler.ReturnValue;
										return @result1!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for this[string @methodHandlers, string @methodHandler, string @result, string @result2, string @self]");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for this[string @methodHandlers, string @methodHandler, string @result, string @result2, string @self])");
						}
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IHaveNamingConflictsCreateExpectations.Handler0, global::System.Func<string, string, string, string, string, int>, int> This(global::Rocks.Argument<string> @methodHandlers, global::Rocks.Argument<string> @methodHandler, global::Rocks.Argument<string> @result, global::Rocks.Argument<string> @result2, global::Rocks.Argument<string> @self)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@methodHandlers);
							global::System.ArgumentNullException.ThrowIfNull(@methodHandler);
							global::System.ArgumentNullException.ThrowIfNull(@result);
							global::System.ArgumentNullException.ThrowIfNull(@result2);
							global::System.ArgumentNullException.ThrowIfNull(@self);
							
							var handler = new global::IHaveNamingConflictsCreateExpectations.Handler0
							{
								@methodHandlers = @methodHandlers,
								@methodHandler = @methodHandler,
								@result = @result,
								@result2 = @result2,
								@self = @self,
							};
							
							if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
							this.Expectations.handlers0.Add(handler);
							return new(handler);
						}
						private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
					}
					
					
					internal IndexerExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveNamingConflictsCreateExpectations.IndexerExpectations.IndexerGetterExpectations Getters { get; }
				}
				
				internal global::IHaveNamingConflictsCreateExpectations.IndexerExpectations Indexers { get; }
				
				internal IHaveNamingConflictsCreateExpectations() =>
					(this.Indexers) = (new(this));
				
				internal global::IHaveNamingConflicts Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IHaveNamingConflicts_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenMethodParameterNamesMatchVariablesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IHaveNamingConflicts>]

			public interface IHaveNamingConflicts
			{
				int Foo(string methodHandlers, string methodHandler, string result, string result2, string self);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IHaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<string, string, string, string, string, int>, int>
				{
					public global::Rocks.Argument<string> @methodHandlers { get; set; }
					public global::Rocks.Argument<string> @methodHandler { get; set; }
					public global::Rocks.Argument<string> @result { get; set; }
					public global::Rocks.Argument<string> @result2 { get; set; }
					public global::Rocks.Argument<string> @self { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IHaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveNamingConflicts
				{
					public Mock(global::IHaveNamingConflictsCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "int Foo(string @methodHandlers, string @methodHandler, string @result, string @result2, string @self)")]
					public int Foo(string @methodHandlers, string @methodHandler, string @result, string @result2, string @self)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@methodHandlers.IsValid(@methodHandlers!) &&
									@handler.@methodHandler.IsValid(@methodHandler!) &&
									@handler.@result.IsValid(@result!) &&
									@handler.@result2.IsValid(@result2!) &&
									@handler.@self.IsValid(@self!))
								{
									@handler.CallCount++;
									var @result1 = @handler.Callback is not null ?
										@handler.Callback(@methodHandlers!, @methodHandler!, @result!, @result2!, @self!) : @handler.ReturnValue;
									return @result1!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers match for int Foo(string @methodHandlers, string @methodHandler, string @result, string @result2, string @self)");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for int Foo(string @methodHandlers, string @methodHandler, string @result, string @result2, string @self)");
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IHaveNamingConflictsCreateExpectations.Handler0, global::System.Func<string, string, string, string, string, int>, int> Foo(global::Rocks.Argument<string> @methodHandlers, global::Rocks.Argument<string> @methodHandler, global::Rocks.Argument<string> @result, global::Rocks.Argument<string> @result2, global::Rocks.Argument<string> @self)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@methodHandlers);
						global::System.ArgumentNullException.ThrowIfNull(@methodHandler);
						global::System.ArgumentNullException.ThrowIfNull(@result);
						global::System.ArgumentNullException.ThrowIfNull(@result2);
						global::System.ArgumentNullException.ThrowIfNull(@self);
						
						var handler = new global::IHaveNamingConflictsCreateExpectations.Handler0
						{
							@methodHandlers = @methodHandlers,
							@methodHandler = @methodHandler,
							@result = @result,
							@result2 = @result2,
							@self = @self,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal global::IHaveNamingConflictsCreateExpectations.MethodExpectations Methods { get; }
				
				internal IHaveNamingConflictsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IHaveNamingConflicts Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IHaveNamingConflicts_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenConstructorHasParameterNameThatMatchesConstructorPropertiesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<HasRequiredProperty>]

			public class HasRequiredProperty
			{
				public HasRequiredProperty(string constructorProperties) { }

				public virtual void Foo() { }

				public required string Data { get; set; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class HasRequiredPropertyCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::HasRequiredPropertyCreateExpectations.Handler0>? @handlers0;
				private global::System.Collections.Generic.List<global::HasRequiredPropertyCreateExpectations.Handler1>? @handlers1;
				private global::System.Collections.Generic.List<global::HasRequiredPropertyCreateExpectations.Handler2>? @handlers2;
				private global::System.Collections.Generic.List<global::HasRequiredPropertyCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1?.Count > 0) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2?.Count > 0) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3?.Count > 0) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::HasRequiredProperty
				{
					[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
					public Mock(global::HasRequiredPropertyCreateExpectations @expectations, ConstructorProperties @constructorProperties1, string @constructorProperties)
						: base(@constructorProperties)
					{
						this.Expectations = @expectations;
						this.Data = @constructorProperties1.Data!;
					}
					
					[global::Rocks.MemberIdentifier(0, "bool Equals(object? @obj)")]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers match for bool Equals(object? @obj)");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1, "int GetHashCode()")]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1?.Count > 0)
						{
							var @handler = this.Expectations.handlers1[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2, "string? ToString()")]
					public override string? ToString()
					{
						if (this.Expectations.handlers2?.Count > 0)
						{
							var @handler = this.Expectations.handlers2[0];
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3, "void Foo()")]
					public override void Foo()
					{
						if (this.Expectations.handlers3?.Count > 0)
						{
							var @handler = this.Expectations.handlers3[0];
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::HasRequiredPropertyCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::HasRequiredPropertyCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::HasRequiredPropertyCreateExpectations.Handler0, global::System.Func<object?, bool>, bool> Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::HasRequiredPropertyCreateExpectations.Handler1, global::System.Func<int>, int> GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers1 is null ) { this.Expectations.handlers1 = new(); }
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler1();
						this.Expectations.handlers1.Add(handler);
						return new(handler);
					}
					
					internal new global::Rocks.Adornments<global::HasRequiredPropertyCreateExpectations.Handler2, global::System.Func<string?>, string?> ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers2 is null ) { this.Expectations.handlers2 = new(); }
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler2();
						this.Expectations.handlers2.Add(handler);
						return new(handler);
					}
					
					internal global::Rocks.Adornments<global::HasRequiredPropertyCreateExpectations.Handler3, global::System.Action> Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						if (this.Expectations.handlers3 is null ) { this.Expectations.handlers3 = new(); }
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler3();
						this.Expectations.handlers3.Add(handler);
						return new(handler);
					}
					
					private global::HasRequiredPropertyCreateExpectations Expectations { get; }
				}
				
				internal global::HasRequiredPropertyCreateExpectations.MethodExpectations Methods { get; }
				
				internal HasRequiredPropertyCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal sealed class ConstructorProperties
				{
					internal required string? Data { get; init; }
				}
				
				internal global::HasRequiredProperty Instance(global::HasRequiredPropertyCreateExpectations.ConstructorProperties @constructorProperties1, string @constructorProperties)
				{
					if (@constructorProperties1 is null)
					{
						throw new global::System.ArgumentNullException(nameof(@constructorProperties1));
					}
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @constructorProperties1, @constructorProperties);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "HasRequiredProperty_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWithMultipleNamespacesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IUsesThing>]

			namespace Namespace1
			{
			  public class Thing { }
			  public class Stuff { }
			}

			namespace Namespace2
			{
			  public class Thing { }
			}

			public interface IUsesThing
			{
			  void Use(Namespace2.Thing thing, Namespace1.Stuff stuff);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IUsesThingCreateExpectations
				: global::Rocks.Expectations
			{
				#pragma warning disable CS8618
				
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<global::Namespace2.Thing, global::Namespace1.Stuff>>
				{
					public global::Rocks.Argument<global::Namespace2.Thing> @thing { get; set; }
					public global::Rocks.Argument<global::Namespace1.Stuff> @stuff { get; set; }
				}
				
				#pragma warning restore CS8618
				
				private global::System.Collections.Generic.List<global::IUsesThingCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUsesThing
				{
					public Mock(global::IUsesThingCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "void Use(global::Namespace2.Thing @thing, global::Namespace1.Stuff @stuff)")]
					public void Use(global::Namespace2.Thing @thing, global::Namespace1.Stuff @stuff)
					{
						if (this.Expectations.handlers0?.Count > 0)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@thing.IsValid(@thing!) &&
									@handler.@stuff.IsValid(@stuff!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@thing!, @stuff!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Use(global::Namespace2.Thing @thing, global::Namespace1.Stuff @stuff)");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Use(global::Namespace2.Thing @thing, global::Namespace1.Stuff @stuff)");
						}
					}
					
					private global::IUsesThingCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUsesThingCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::Rocks.Adornments<global::IUsesThingCreateExpectations.Handler0, global::System.Action<global::Namespace2.Thing, global::Namespace1.Stuff>> Use(global::Rocks.Argument<global::Namespace2.Thing> @thing, global::Rocks.Argument<global::Namespace1.Stuff> @stuff)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@thing);
						global::System.ArgumentNullException.ThrowIfNull(@stuff);
						
						var handler = new global::IUsesThingCreateExpectations.Handler0
						{
							@thing = @thing,
							@stuff = @stuff,
						};
						
						if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
						this.Expectations.handlers0.Add(handler);
						return new(handler);
					}
					
					private global::IUsesThingCreateExpectations Expectations { get; }
				}
				
				internal global::IUsesThingCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUsesThingCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IUsesThing Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IUsesThing_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWithArrayAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<IUseMethodInformation>]

			public class MethodInformation { }

			public interface IUseMethodInformation
			{
				MethodInformation[] Methods { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IUseMethodInformationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::MethodInformation[]>, global::MethodInformation[]>
				{ }
				
				private global::System.Collections.Generic.List<global::IUseMethodInformationCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUseMethodInformation
				{
					public Mock(global::IUseMethodInformationCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "get_Methods()")]
					public global::MethodInformation[] Methods
					{
						get
						{
							if (this.Expectations.handlers0?.Count > 0)
							{
								var @handler = this.Expectations.handlers0[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for get_Methods())");
						}
					}
					
					private global::IUseMethodInformationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IUseMethodInformationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IUseMethodInformationCreateExpectations.Handler0, global::System.Func<global::MethodInformation[]>, global::MethodInformation[]> Methods()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
							var handler = new global::IUseMethodInformationCreateExpectations.Handler0();
							this.Expectations.handlers0.Add(handler);
							return new(handler);
						}
						private global::IUseMethodInformationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IUseMethodInformationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IUseMethodInformationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				
				internal global::IUseMethodInformationCreateExpectations.PropertyExpectations Properties { get; }
				
				internal IUseMethodInformationCreateExpectations() =>
					(this.Properties) = (new(this));
				
				internal global::IUseMethodInformation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IUseMethodInformation_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWithNestedTypeAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<IOperation>]

			public interface IOperation
			{
				public struct OperationList { }

				OperationList Operations { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			internal sealed class IOperationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::IOperation.OperationList>, global::IOperation.OperationList>
				{ }
				
				private global::System.Collections.Generic.List<global::IOperationCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IOperation
				{
					public Mock(global::IOperationCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, "get_Operations()")]
					public global::IOperation.OperationList Operations
					{
						get
						{
							if (this.Expectations.handlers0?.Count > 0)
							{
								var @handler = this.Expectations.handlers0[0];
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for get_Operations())");
						}
					}
					
					private global::IOperationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IOperationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::IOperationCreateExpectations.Handler0, global::System.Func<global::IOperation.OperationList>, global::IOperation.OperationList> Operations()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
							var handler = new global::IOperationCreateExpectations.Handler0();
							this.Expectations.handlers0.Add(handler);
							return new(handler);
						}
						private global::IOperationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IOperationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IOperationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				
				internal global::IOperationCreateExpectations.PropertyExpectations Properties { get; }
				
				internal IOperationCreateExpectations() =>
					(this.Properties) = (new(this));
				
				internal global::IOperation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "IOperation_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWithConstraintAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<Namespace2.IUseConstraint>]

			namespace Namespace1
			{
				public interface IConstraint { }
			}

			namespace Namespace2
			{
				public interface IUseConstraint
				{
					void Foo<T>(T value) where T : Namespace1.IConstraint;
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			namespace Namespace2
			{
				internal sealed class IUseConstraintCreateExpectations
					: global::Rocks.Expectations
				{
					#pragma warning disable CS8618
					
					internal sealed class Handler0<T>
						: global::Rocks.Handler<global::System.Action<T>>
						where T : global::Namespace1.IConstraint
					{
						public global::Rocks.Argument<T> @value { get; set; }
					}
					
					#pragma warning restore CS8618
					
					private global::System.Collections.Generic.List<global::Rocks.Handler>? @handlers0;
					
					public override void Verify()
					{
						if (this.WasInstanceInvoked)
						{
							var failures = new global::System.Collections.Generic.List<string>();
					
							if (this.handlers0?.Count > 0) { failures.AddRange(this.Verify(this.handlers0, 0)); }
					
							if (failures.Count > 0)
							{
								throw new global::Rocks.Exceptions.VerificationException(failures);
							}
						}
					}
					
					private sealed class Mock
						: global::Namespace2.IUseConstraint
					{
						public Mock(global::Namespace2.IUseConstraintCreateExpectations @expectations)
						{
							this.Expectations = @expectations;
						}
						
						[global::Rocks.MemberIdentifier(0, "void Foo<T>(T @value)")]
						public void Foo<T>(T @value)
							where T : global::Namespace1.IConstraint
						{
							if (this.Expectations.handlers0?.Count > 0)
							{
								var @foundMatch = false;
								
								foreach (var @genericHandler in this.Expectations.handlers0)
								{
									if (@genericHandler is global::Namespace2.IUseConstraintCreateExpectations.Handler0<T> @handler)
									{
										if (@handler.@value.IsValid(@value!))
										{
											@foundMatch = true;
											@handler.CallCount++;
											@handler.Callback?.Invoke(@value!);
											break;
										}
									}
								}
								
								if (!@foundMatch)
								{
									throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Foo<T>(T @value)");
								}
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Foo<T>(T @value)");
							}
						}
						
						private global::Namespace2.IUseConstraintCreateExpectations Expectations { get; }
					}
					
					internal sealed class MethodExpectations
					{
						internal MethodExpectations(global::Namespace2.IUseConstraintCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Rocks.Adornments<global::Namespace2.IUseConstraintCreateExpectations.Handler0<T>, global::System.Action<T>> Foo<T>(global::Rocks.Argument<T> @value) where T : global::Namespace1.IConstraint
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@value);
							
							var handler = new global::Namespace2.IUseConstraintCreateExpectations.Handler0<T>
							{
								@value = @value,
							};
							
							if (this.Expectations.handlers0 is null ) { this.Expectations.handlers0 = new(); }
							this.Expectations.handlers0.Add(handler);
							return new(handler);
						}
						
						private global::Namespace2.IUseConstraintCreateExpectations Expectations { get; }
					}
					
					internal global::Namespace2.IUseConstraintCreateExpectations.MethodExpectations Methods { get; }
					
					internal IUseConstraintCreateExpectations() =>
						(this.Methods) = (new(this));
					
					internal global::Namespace2.IUseConstraint Instance()
					{
						if (!this.WasInstanceInvoked)
						{
							this.WasInstanceInvoked = true;
							var @mock = new Mock(this);
							this.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockAttributeGenerator>(code,
			new[] { (typeof(RockAttributeGenerator), "Namespace2.IUseConstraint_Rock_Create.g.cs", generatedCode) },
			[]).ConfigureAwait(false);
	}
}