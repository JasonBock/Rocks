using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class NamingGeneratorTests
{
	[Test]
	public static async Task CreateWithDuplicateExpectationsNameAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<IHandle>]

			public interface IHandle
			{
				void Handle();
			}

			public interface IHandleCreateExpectations { }
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IHandleCreateExpectations2
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::IHandleCreateExpectations2.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHandle
				{
					public Mock(global::IHandleCreateExpectations2 @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Handle()
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @handler = this.Expectations.handlers0.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IHandleCreateExpectations2 Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHandleCreateExpectations2 expectations) =>
						this.Expectations = expectations;
					
					internal global::IHandleCreateExpectations2.Adornments.AdornmentsForHandler0 Handle()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHandleCreateExpectations2.Handler0();
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
						else { this.Expectations.handlers0.Add(handler); }
						return new(handler);
					}
					
					private global::IHandleCreateExpectations2 Expectations { get; }
				}
				
				internal global::IHandleCreateExpectations2.MethodExpectations Methods { get; }
				
				internal IHandleCreateExpectations2() =>
					(this.Methods) = (new(this));
				
				internal global::IHandle Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHandle<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHandle<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHandleCreateExpectations2.Handler0, global::System.Action>, IAdornmentsForIHandle<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHandleCreateExpectations2.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IHandle_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithDuplicateExpectationsNameInNamespaceAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<Names.IHandle>]
			
			namespace Names;

			public interface IHandle
			{
				void Handle();
			}
			
			public interface IHandleCreateExpectations { }
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			namespace Names
			{
				internal sealed class IHandleCreateExpectations2
					: global::Rocks.Expectations
				{
					internal sealed class Handler0
						: global::Rocks.Handler<global::System.Action>
					{ }
					private global::Rocks.Handlers<global::Names.IHandleCreateExpectations2.Handler0>? @handlers0;
					
					public override void Verify()
					{
						if (this.WasInstanceInvoked)
						{
							var failures = new global::System.Collections.Generic.List<string>();
					
							if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
					
							if (failures.Count > 0)
							{
								throw new global::Rocks.Exceptions.VerificationException(failures);
							}
						}
					}
					
					private sealed class Mock
						: global::Names.IHandle
					{
						public Mock(global::Names.IHandleCreateExpectations2 @expectations)
						{
							this.Expectations = @expectations;
						}
						
						[global::Rocks.MemberIdentifier(0)]
						public void Handle()
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								@handler.Callback?.Invoke();
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
							}
						}
						
						private global::Names.IHandleCreateExpectations2 Expectations { get; }
					}
					
					internal sealed class MethodExpectations
					{
						internal MethodExpectations(global::Names.IHandleCreateExpectations2 expectations) =>
							this.Expectations = expectations;
						
						internal global::Names.IHandleCreateExpectations2.Adornments.AdornmentsForHandler0 Handle()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::Names.IHandleCreateExpectations2.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						
						private global::Names.IHandleCreateExpectations2 Expectations { get; }
					}
					
					internal global::Names.IHandleCreateExpectations2.MethodExpectations Methods { get; }
					
					internal IHandleCreateExpectations2() =>
						(this.Methods) = (new(this));
					
					internal global::Names.IHandle Instance()
					{
						if (!this.WasInstanceInvoked)
						{
							this.WasInstanceInvoked = true;
							var @mock = new Mock(this);
							this.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
					
					internal static class Adornments
					{
						public interface IAdornmentsForIHandle<TAdornments>
							: global::Rocks.IAdornments<TAdornments>
							where TAdornments : IAdornmentsForIHandle<TAdornments>
						{ }
						
						public sealed class AdornmentsForHandler0
							: global::Rocks.Adornments<AdornmentsForHandler0, global::Names.IHandleCreateExpectations2.Handler0, global::System.Action>, IAdornmentsForIHandle<AdornmentsForHandler0>
						{
							public AdornmentsForHandler0(global::Names.IHandleCreateExpectations2.Handler0 handler)
								: base(handler) { }
						}
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "Names.IHandle_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithHandlerParameterNameAsync()
	{
		var code =
			"""
			using Rocks;

			[assembly: RockCreate<IHandle>]

			public interface IHandle
			{
				void Handle(string handler);
				int this[string handler] { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IHandleCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<string>>
				{
					public global::Rocks.Argument<string> @handler { get; set; }
				}
				private global::Rocks.Handlers<global::IHandleCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<string, int>, int>
				{
					public global::Rocks.Argument<string> @handler { get; set; }
				}
				private global::Rocks.Handlers<global::IHandleCreateExpectations.Handler1>? @handlers1;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHandle
				{
					public Mock(global::IHandleCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Handle(string @handler)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler1 in this.Expectations.handlers0)
							{
								if (@handler1.@handler.IsValid(@handler!))
								{
									@foundMatch = true;
									@handler1.CallCount++;
									@handler1.Callback?.Invoke(@handler!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					[global::Rocks.MemberIdentifier(1, global::Rocks.PropertyAccessor.Get)]
					public int this[string @handler]
					{
						get
						{
							if (this.Expectations.handlers1 is not null)
							{
								foreach (var @handler1 in this.Expectations.handlers1)
								{
									if (@handler1.@handler.IsValid(@handler!))
									{
										@handler1.CallCount++;
										var @result = @handler1.Callback is not null ?
											@handler1.Callback(@handler!) : @handler1.ReturnValue;
										return @result!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(1)}");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(1)})");
						}
					}
					
					private global::IHandleCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHandleCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IHandleCreateExpectations.Adornments.AdornmentsForHandler0 Handle(global::Rocks.Argument<string> @handler)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@handler);
						
						var @handler1 = new global::IHandleCreateExpectations.Handler0
						{
							@handler = @handler,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler1); }
						else { this.Expectations.handlers0.Add(@handler1); }
						return new(@handler1);
					}
					
					private global::IHandleCreateExpectations Expectations { get; }
				}
				
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IHandleCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IHandleCreateExpectations.Adornments.AdornmentsForHandler1 This(global::Rocks.Argument<string> @handler)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@handler);
							
							var @handler1 = new global::IHandleCreateExpectations.Handler1
							{
								@handler = @handler,
							};
							
							if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(@handler1); }
							else { this.Expectations.handlers1.Add(@handler1); }
							return new(@handler1);
						}
						private global::IHandleCreateExpectations Expectations { get; }
					}
					
					
					internal IndexerExpectations(global::IHandleCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHandleCreateExpectations.IndexerExpectations.IndexerGetterExpectations Getters { get; }
				}
				
				internal global::IHandleCreateExpectations.MethodExpectations Methods { get; }
				internal global::IHandleCreateExpectations.IndexerExpectations Indexers { get; }
				
				internal IHandleCreateExpectations() =>
					(this.Methods, this.Indexers) = (new(this), new(this));
				
				internal global::IHandle Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHandle<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHandle<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHandleCreateExpectations.Handler0, global::System.Action<string>>, IAdornmentsForIHandle<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHandleCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IHandleCreateExpectations.Handler1, global::System.Func<string, int>, int>, IAdornmentsForIHandle<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IHandleCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IHandle_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task CreateWithDuplicateTypeNamesAsync()
	{
		var references = Shared.References.Value
			.Cast<MetadataReference>()
			.ToList();

		var firstSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}

			public interface IUseSameNames
			{
				void Use(SameNamespace.SameType value);
			}			
			""";
		var firstSourceSyntaxTree = CSharpSyntaxTree.ParseText(firstSource);
		var firstSourceCompilation = CSharpCompilation.Create("first", [firstSourceSyntaxTree],
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var firstSourceReference = firstSourceCompilation.ToMetadataReference()!;
		firstSourceReference = firstSourceReference.WithAliases(["First"]);

		var secondSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}
			""";
		var secondSourceSyntaxTree = CSharpSyntaxTree.ParseText(secondSource);
		var secondSourceCompilation = CSharpCompilation.Create("second", [secondSourceSyntaxTree],
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var secondSourceReference = secondSourceCompilation.ToMetadataReference()!;

		var code =
			"""
			extern alias First;

			using Rocks;

			[assembly: RockCreate<First.IUseSameNames>]
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			extern alias First;
			
			using Rocks.Extensions;
			
			internal sealed class IUseSameNamesCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<First::SameNamespace.SameType>>
				{
					public global::Rocks.Argument<First::SameNamespace.SameType> @value { get; set; }
				}
				private global::Rocks.Handlers<global::IUseSameNamesCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: First::IUseSameNames
				{
					public Mock(global::IUseSameNamesCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Use(First::SameNamespace.SameType @value)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@value.IsValid(@value!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@value!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IUseSameNamesCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUseSameNamesCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IUseSameNamesCreateExpectations.Adornments.AdornmentsForHandler0 Use(global::Rocks.Argument<First::SameNamespace.SameType> @value)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@value);
						
						var @handler = new global::IUseSameNamesCreateExpectations.Handler0
						{
							@value = @value,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IUseSameNamesCreateExpectations Expectations { get; }
				}
				
				internal global::IUseSameNamesCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUseSameNamesCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal First::IUseSameNames Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIUseSameNames<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIUseSameNames<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IUseSameNamesCreateExpectations.Handler0, global::System.Action<First::SameNamespace.SameType>>, IAdornmentsForIUseSameNames<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IUseSameNamesCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		references.AddRange([firstSourceReference, secondSourceReference]);

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "FirstIUseSameNames_Rock_Create.g.cs", generatedCode)],
			[],
			additionalReferences: references);
	}

	[Test]
	public static async Task MakeWithDuplicateTypeNamesAsync()
	{
		var references = Shared.References.Value
			.Cast<MetadataReference>()
			.ToList();

		var firstSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}

			public interface IUseSameNames
			{
				void Use(SameNamespace.SameType value);
			}			
			""";
		var firstSourceSyntaxTree = CSharpSyntaxTree.ParseText(firstSource);
		var firstSourceCompilation = CSharpCompilation.Create("first", [firstSourceSyntaxTree],
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var firstSourceReference = firstSourceCompilation.ToMetadataReference()!;
		firstSourceReference = firstSourceReference.WithAliases(["First"]);

		var secondSource =
			"""
			namespace SameNamespace
			{
				public class SameType { }
			}
			""";
		var secondSourceSyntaxTree = CSharpSyntaxTree.ParseText(secondSource);
		var secondSourceCompilation = CSharpCompilation.Create("second", [secondSourceSyntaxTree],
			references,
			new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
		var secondSourceReference = secondSourceCompilation.ToMetadataReference()!;

		var code =
			"""
			extern alias First;

			using Rocks;

			[assembly: RockMake<First.IUseSameNames>]
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			extern alias First;
			
			internal sealed class IUseSameNamesMakeExpectations
			{
				internal First::IUseSameNames Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: First::IUseSameNames
				{
					public Mock()
					{
					}
					
					public void Use(First::SameNamespace.SameType @value)
					{
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		references.AddRange([firstSourceReference, secondSourceReference]);

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "FirstIUseSameNames_Rock_Make.g.cs", generatedCode)],
			[],
			additionalReferences: references);
	}

	[Test]
	public static async Task MakeWithGenericReturnsAsync()
	{
		var code =
			"""
			using Rocks;
			using System.Threading.Tasks;

			[assembly: RockMake<DbSet<object>>]

			public class EntityEntry<TEntity>
				where TEntity : class { }

			public class DbSet<TEntity>
				where TEntity : class
			{
				public virtual ValueTask<EntityEntry<TEntity>> AddAsync() =>
					new();
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			internal sealed class DbSetOfobjectMakeExpectations
			{
				internal global::DbSet<object> Instance()
				{
					return new Mock();
				}
				
				private sealed class Mock
					: global::DbSet<object>
				{
					public Mock()
					{
					}
					
					public override bool Equals(object? @obj)
					{
						return default!;
					}
					public override int GetHashCode()
					{
						return default!;
					}
					public override string? ToString()
					{
						return default!;
					}
					public override global::System.Threading.Tasks.ValueTask<global::EntityEntry<object>> AddAsync()
					{
						return new global::System.Threading.Tasks.ValueTask<global::EntityEntry<object>>(default(global::EntityEntry<object>)!);
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "DbSetobject_Rock_Make.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenNonVirtualMembersAreNeededAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			using System.IO;

			[assembly: RockCreate<IHaveDelegate>]

			public class IHaveDelegate
			{
				public Func<Stream, Stream> Processor { get; init; }   
				public virtual void Foo() { }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IHaveDelegateCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::IHaveDelegateCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::IHaveDelegateCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::IHaveDelegateCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::IHaveDelegateCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveDelegate
				{
					public Mock(global::IHaveDelegateCreateExpectations @expectations, ConstructorProperties? @constructorProperties)
					{
						this.Expectations = @expectations;
						if (@constructorProperties is not null)
						{
							this.Processor = @constructorProperties.Processor!;
						}
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3)]
					public override void Foo()
					{
						if (this.Expectations.handlers3 is not null)
						{
							var @handler = this.Expectations.handlers3.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::IHaveDelegateCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveDelegateCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IHaveDelegateCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::IHaveDelegateCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::IHaveDelegateCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHaveDelegateCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::IHaveDelegateCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHaveDelegateCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::IHaveDelegateCreateExpectations.Adornments.AdornmentsForHandler3 Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::IHaveDelegateCreateExpectations.Handler3();
						if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(handler); }
						else { this.Expectations.handlers3.Add(handler); }
						return new(handler);
					}
					
					private global::IHaveDelegateCreateExpectations Expectations { get; }
				}
				
				internal global::IHaveDelegateCreateExpectations.MethodExpectations Methods { get; }
				
				internal IHaveDelegateCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal sealed class ConstructorProperties
				{
					internal global::System.Func<global::System.IO.Stream, global::System.IO.Stream>? Processor { get; init; }
				}
				
				internal global::IHaveDelegate Instance(global::IHaveDelegateCreateExpectations.ConstructorProperties? @constructorProperties)
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @constructorProperties);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHaveDelegate<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHaveDelegate<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHaveDelegateCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForIHaveDelegate<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHaveDelegateCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::IHaveDelegateCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForIHaveDelegate<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::IHaveDelegateCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::IHaveDelegateCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForIHaveDelegate<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::IHaveDelegateCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::IHaveDelegateCreateExpectations.Handler3, global::System.Action>, IAdornmentsForIHaveDelegate<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::IHaveDelegateCreateExpectations.Handler3 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IHaveDelegate_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenNamesAreKeywordsAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IUseKeyword>]

			public interface IUseKeyword
			{
			    void Foo(string @namespace, string @event, string @property);   
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IUseKeywordCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<string, string, string>>
				{
					public global::Rocks.Argument<string> @namespace { get; set; }
					public global::Rocks.Argument<string> @event { get; set; }
					public global::Rocks.Argument<string> @property { get; set; }
				}
				private global::Rocks.Handlers<global::IUseKeywordCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUseKeyword
				{
					public Mock(global::IUseKeywordCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Foo(string @namespace, string @event, string @property)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@namespace.IsValid(@namespace!) &&
									@handler.@event.IsValid(@event!) &&
									@handler.@property.IsValid(@property!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@namespace!, @event!, @property!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IUseKeywordCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUseKeywordCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IUseKeywordCreateExpectations.Adornments.AdornmentsForHandler0 Foo(global::Rocks.Argument<string> @namespace, global::Rocks.Argument<string> @event, global::Rocks.Argument<string> @property)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@namespace);
						global::System.ArgumentNullException.ThrowIfNull(@event);
						global::System.ArgumentNullException.ThrowIfNull(@property);
						
						var @handler = new global::IUseKeywordCreateExpectations.Handler0
						{
							@namespace = @namespace,
							@event = @event,
							@property = @property,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IUseKeywordCreateExpectations Expectations { get; }
				}
				
				internal global::IUseKeywordCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUseKeywordCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IUseKeyword Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIUseKeyword<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIUseKeyword<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IUseKeywordCreateExpectations.Handler0, global::System.Action<string, string, string>>, IAdornmentsForIUseKeyword<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IUseKeywordCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";
			
		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IUseKeyword_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWithConstructorWithSelfNameAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<HaveNamingConflicts>]

			public class HaveNamingConflicts
			{
				public HaveNamingConflicts(string self, string expectations) { }
				public virtual void Foo() { }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class HaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::HaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::HaveNamingConflictsCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::HaveNamingConflictsCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::HaveNamingConflictsCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::HaveNamingConflicts
				{
					public Mock(global::HaveNamingConflictsCreateExpectations @expectations1, string @self, string @expectations)
						: base(@self, @expectations)
					{
						this.Expectations = @expectations1;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3)]
					public override void Foo()
					{
						if (this.Expectations.handlers3 is not null)
						{
							var @handler = this.Expectations.handlers3.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::HaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::HaveNamingConflictsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::HaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::HaveNamingConflictsCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::HaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::HaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::HaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler3 Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HaveNamingConflictsCreateExpectations.Handler3();
						if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(handler); }
						else { this.Expectations.handlers3.Add(handler); }
						return new(handler);
					}
					
					private global::HaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal global::HaveNamingConflictsCreateExpectations.MethodExpectations Methods { get; }
				
				internal HaveNamingConflictsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::HaveNamingConflicts Instance(string @self, string @expectations)
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @self, @expectations);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForHaveNamingConflicts<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForHaveNamingConflicts<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::HaveNamingConflictsCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForHaveNamingConflicts<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::HaveNamingConflictsCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::HaveNamingConflictsCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForHaveNamingConflicts<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::HaveNamingConflictsCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::HaveNamingConflictsCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForHaveNamingConflicts<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::HaveNamingConflictsCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::HaveNamingConflictsCreateExpectations.Handler3, global::System.Action>, IAdornmentsForHaveNamingConflicts<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::HaveNamingConflictsCreateExpectations.Handler3 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "HaveNamingConflicts_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenIndexerParameterNamesMatchVariablesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IHaveNamingConflicts>]

			public interface IHaveNamingConflicts
			{
				int this[string methodHandlers, string methodHandler, string result, string result2, string self] { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IHaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<string, string, string, string, string, int>, int>
				{
					public global::Rocks.Argument<string> @methodHandlers { get; set; }
					public global::Rocks.Argument<string> @methodHandler { get; set; }
					public global::Rocks.Argument<string> @result { get; set; }
					public global::Rocks.Argument<string> @result2 { get; set; }
					public global::Rocks.Argument<string> @self { get; set; }
				}
				private global::Rocks.Handlers<global::IHaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveNamingConflicts
				{
					public Mock(global::IHaveNamingConflictsCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public int this[string @methodHandlers, string @methodHandler, string @result, string @result2, string @self]
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								foreach (var @handler in this.Expectations.handlers0)
								{
									if (@handler.@methodHandlers.IsValid(@methodHandlers!) &&
										@handler.@methodHandler.IsValid(@methodHandler!) &&
										@handler.@result.IsValid(@result!) &&
										@handler.@result2.IsValid(@result2!) &&
										@handler.@self.IsValid(@self!))
									{
										@handler.CallCount++;
										var @result1 = @handler.Callback is not null ?
											@handler.Callback(@methodHandlers!, @methodHandler!, @result!, @result2!, @self!) : @handler.ReturnValue;
										return @result1!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)})");
						}
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				internal sealed class IndexerExpectations
				{
					internal sealed class IndexerGetterExpectations
					{
						internal IndexerGetterExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IHaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler0 This(global::Rocks.Argument<string> @methodHandlers, global::Rocks.Argument<string> @methodHandler, global::Rocks.Argument<string> @result, global::Rocks.Argument<string> @result2, global::Rocks.Argument<string> @self)
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@methodHandlers);
							global::System.ArgumentNullException.ThrowIfNull(@methodHandler);
							global::System.ArgumentNullException.ThrowIfNull(@result);
							global::System.ArgumentNullException.ThrowIfNull(@result2);
							global::System.ArgumentNullException.ThrowIfNull(@self);
							
							var @handler = new global::IHaveNamingConflictsCreateExpectations.Handler0
							{
								@methodHandlers = @methodHandlers,
								@methodHandler = @methodHandler,
								@result = @result,
								@result2 = @result2,
								@self = @self,
							};
							
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
							else { this.Expectations.handlers0.Add(@handler); }
							return new(@handler);
						}
						private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
					}
					
					
					internal IndexerExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IHaveNamingConflictsCreateExpectations.IndexerExpectations.IndexerGetterExpectations Getters { get; }
				}
				
				internal global::IHaveNamingConflictsCreateExpectations.IndexerExpectations Indexers { get; }
				
				internal IHaveNamingConflictsCreateExpectations() =>
					(this.Indexers) = (new(this));
				
				internal global::IHaveNamingConflicts Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHaveNamingConflicts<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHaveNamingConflicts<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHaveNamingConflictsCreateExpectations.Handler0, global::System.Func<string, string, string, string, string, int>, int>, IAdornmentsForIHaveNamingConflicts<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHaveNamingConflictsCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IHaveNamingConflicts_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenMethodParameterNamesMatchVariablesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IHaveNamingConflicts>]

			public interface IHaveNamingConflicts
			{
				int Foo(string methodHandlers, string methodHandler, string result, string result2, string self);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IHaveNamingConflictsCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<string, string, string, string, string, int>, int>
				{
					public global::Rocks.Argument<string> @methodHandlers { get; set; }
					public global::Rocks.Argument<string> @methodHandler { get; set; }
					public global::Rocks.Argument<string> @result { get; set; }
					public global::Rocks.Argument<string> @result2 { get; set; }
					public global::Rocks.Argument<string> @self { get; set; }
				}
				private global::Rocks.Handlers<global::IHaveNamingConflictsCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IHaveNamingConflicts
				{
					public Mock(global::IHaveNamingConflictsCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public int Foo(string @methodHandlers, string @methodHandler, string @result, string @result2, string @self)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@methodHandlers.IsValid(@methodHandlers!) &&
									@handler.@methodHandler.IsValid(@methodHandler!) &&
									@handler.@result.IsValid(@result!) &&
									@handler.@result2.IsValid(@result2!) &&
									@handler.@self.IsValid(@self!))
								{
									@handler.CallCount++;
									var @result1 = @handler.Callback is not null ?
										@handler.Callback(@methodHandlers!, @methodHandler!, @result!, @result2!, @self!) : @handler.ReturnValue;
									return @result1!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						
						throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IHaveNamingConflictsCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IHaveNamingConflictsCreateExpectations.Adornments.AdornmentsForHandler0 Foo(global::Rocks.Argument<string> @methodHandlers, global::Rocks.Argument<string> @methodHandler, global::Rocks.Argument<string> @result, global::Rocks.Argument<string> @result2, global::Rocks.Argument<string> @self)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@methodHandlers);
						global::System.ArgumentNullException.ThrowIfNull(@methodHandler);
						global::System.ArgumentNullException.ThrowIfNull(@result);
						global::System.ArgumentNullException.ThrowIfNull(@result2);
						global::System.ArgumentNullException.ThrowIfNull(@self);
						
						var @handler = new global::IHaveNamingConflictsCreateExpectations.Handler0
						{
							@methodHandlers = @methodHandlers,
							@methodHandler = @methodHandler,
							@result = @result,
							@result2 = @result2,
							@self = @self,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IHaveNamingConflictsCreateExpectations Expectations { get; }
				}
				
				internal global::IHaveNamingConflictsCreateExpectations.MethodExpectations Methods { get; }
				
				internal IHaveNamingConflictsCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IHaveNamingConflicts Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIHaveNamingConflicts<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIHaveNamingConflicts<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IHaveNamingConflictsCreateExpectations.Handler0, global::System.Func<string, string, string, string, string, int>, int>, IAdornmentsForIHaveNamingConflicts<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IHaveNamingConflictsCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IHaveNamingConflicts_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWhenConstructorHasParameterNameThatMatchesConstructorPropertiesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<HasRequiredProperty>]

			public class HasRequiredProperty
			{
				public HasRequiredProperty(string constructorProperties) { }

				public virtual void Foo() { }

				public required string Data { get; set; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class HasRequiredPropertyCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<object?, bool>, bool>
				{
					public global::Rocks.Argument<object?> @obj { get; set; }
				}
				private global::Rocks.Handlers<global::HasRequiredPropertyCreateExpectations.Handler0>? @handlers0;
				internal sealed class Handler1
					: global::Rocks.Handler<global::System.Func<int>, int>
				{ }
				private global::Rocks.Handlers<global::HasRequiredPropertyCreateExpectations.Handler1>? @handlers1;
				internal sealed class Handler2
					: global::Rocks.Handler<global::System.Func<string?>, string?>
				{ }
				private global::Rocks.Handlers<global::HasRequiredPropertyCreateExpectations.Handler2>? @handlers2;
				internal sealed class Handler3
					: global::Rocks.Handler<global::System.Action>
				{ }
				private global::Rocks.Handlers<global::HasRequiredPropertyCreateExpectations.Handler3>? @handlers3;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
						if (this.handlers1 is not null) { failures.AddRange(this.Verify(this.handlers1, 1)); }
						if (this.handlers2 is not null) { failures.AddRange(this.Verify(this.handlers2, 2)); }
						if (this.handlers3 is not null) { failures.AddRange(this.Verify(this.handlers3, 3)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::HasRequiredProperty
				{
					[global::System.Diagnostics.CodeAnalysis.SetsRequiredMembers]
					public Mock(global::HasRequiredPropertyCreateExpectations @expectations, ConstructorProperties @constructorProperties1, string @constructorProperties)
						: base(@constructorProperties)
					{
						this.Expectations = @expectations;
						this.Data = @constructorProperties1.Data!;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public override bool Equals(object? @obj)
					{
						if (this.Expectations.handlers0 is not null)
						{
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@obj.IsValid(@obj!))
								{
									@handler.CallCount++;
									var @result = @handler.Callback is not null ?
										@handler.Callback(@obj!) : @handler.ReturnValue;
									return @result!;
								}
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
						}
						else
						{
							return base.Equals(obj: @obj!);
						}
					}
					
					[global::Rocks.MemberIdentifier(1)]
					public override int GetHashCode()
					{
						if (this.Expectations.handlers1 is not null)
						{
							var @handler = this.Expectations.handlers1.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.GetHashCode();
						}
					}
					
					[global::Rocks.MemberIdentifier(2)]
					public override string? ToString()
					{
						if (this.Expectations.handlers2 is not null)
						{
							var @handler = this.Expectations.handlers2.First;
							@handler.CallCount++;
							var @result = @handler.Callback is not null ?
								@handler.Callback() : @handler.ReturnValue;
							return @result!;
						}
						else
						{
							return base.ToString();
						}
					}
					
					[global::Rocks.MemberIdentifier(3)]
					public override void Foo()
					{
						if (this.Expectations.handlers3 is not null)
						{
							var @handler = this.Expectations.handlers3.First;
							@handler.CallCount++;
							@handler.Callback?.Invoke();
						}
						else
						{
							base.Foo();
						}
					}
					
					private global::HasRequiredPropertyCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::HasRequiredPropertyCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::HasRequiredPropertyCreateExpectations.Adornments.AdornmentsForHandler0 Equals(global::Rocks.Argument<object?> @obj)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@obj);
						
						var @handler = new global::HasRequiredPropertyCreateExpectations.Handler0
						{
							@obj = @obj,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					internal new global::HasRequiredPropertyCreateExpectations.Adornments.AdornmentsForHandler1 GetHashCode()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler1();
						if (this.Expectations.handlers1 is null) { this.Expectations.handlers1 = new(handler); }
						else { this.Expectations.handlers1.Add(handler); }
						return new(handler);
					}
					
					internal new global::HasRequiredPropertyCreateExpectations.Adornments.AdornmentsForHandler2 ToString()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler2();
						if (this.Expectations.handlers2 is null) { this.Expectations.handlers2 = new(handler); }
						else { this.Expectations.handlers2.Add(handler); }
						return new(handler);
					}
					
					internal global::HasRequiredPropertyCreateExpectations.Adornments.AdornmentsForHandler3 Foo()
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						var handler = new global::HasRequiredPropertyCreateExpectations.Handler3();
						if (this.Expectations.handlers3 is null) { this.Expectations.handlers3 = new(handler); }
						else { this.Expectations.handlers3.Add(handler); }
						return new(handler);
					}
					
					private global::HasRequiredPropertyCreateExpectations Expectations { get; }
				}
				
				internal global::HasRequiredPropertyCreateExpectations.MethodExpectations Methods { get; }
				
				internal HasRequiredPropertyCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal sealed class ConstructorProperties
				{
					internal required string? Data { get; init; }
				}
				
				internal global::HasRequiredProperty Instance(global::HasRequiredPropertyCreateExpectations.ConstructorProperties @constructorProperties1, string @constructorProperties)
				{
					if (@constructorProperties1 is null)
					{
						throw new global::System.ArgumentNullException(nameof(@constructorProperties1));
					}
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this, @constructorProperties1, @constructorProperties);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForHasRequiredProperty<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForHasRequiredProperty<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::HasRequiredPropertyCreateExpectations.Handler0, global::System.Func<object?, bool>, bool>, IAdornmentsForHasRequiredProperty<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::HasRequiredPropertyCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler1
						: global::Rocks.Adornments<AdornmentsForHandler1, global::HasRequiredPropertyCreateExpectations.Handler1, global::System.Func<int>, int>, IAdornmentsForHasRequiredProperty<AdornmentsForHandler1>
					{
						public AdornmentsForHandler1(global::HasRequiredPropertyCreateExpectations.Handler1 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler2
						: global::Rocks.Adornments<AdornmentsForHandler2, global::HasRequiredPropertyCreateExpectations.Handler2, global::System.Func<string?>, string?>, IAdornmentsForHasRequiredProperty<AdornmentsForHandler2>
					{
						public AdornmentsForHandler2(global::HasRequiredPropertyCreateExpectations.Handler2 handler)
							: base(handler) { }
					}
					public sealed class AdornmentsForHandler3
						: global::Rocks.Adornments<AdornmentsForHandler3, global::HasRequiredPropertyCreateExpectations.Handler3, global::System.Action>, IAdornmentsForHasRequiredProperty<AdornmentsForHandler3>
					{
						public AdornmentsForHandler3(global::HasRequiredPropertyCreateExpectations.Handler3 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";
 
		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "HasRequiredProperty_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWithMultipleNamespacesAsync()
	{
		var code =
			"""
			using Rocks;
			
			[assembly: RockCreate<IUsesThing>]

			namespace Namespace1
			{
			  public class Thing { }
			  public class Stuff { }
			}

			namespace Namespace2
			{
			  public class Thing { }
			}

			public interface IUsesThing
			{
			  void Use(Namespace2.Thing thing, Namespace1.Stuff stuff);
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IUsesThingCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Action<global::Namespace2.Thing, global::Namespace1.Stuff>>
				{
					public global::Rocks.Argument<global::Namespace2.Thing> @thing { get; set; }
					public global::Rocks.Argument<global::Namespace1.Stuff> @stuff { get; set; }
				}
				private global::Rocks.Handlers<global::IUsesThingCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUsesThing
				{
					public Mock(global::IUsesThingCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0)]
					public void Use(global::Namespace2.Thing @thing, global::Namespace1.Stuff @stuff)
					{
						if (this.Expectations.handlers0 is not null)
						{
							var @foundMatch = false;
							
							foreach (var @handler in this.Expectations.handlers0)
							{
								if (@handler.@thing.IsValid(@thing!) &&
									@handler.@stuff.IsValid(@stuff!))
								{
									@foundMatch = true;
									@handler.CallCount++;
									@handler.Callback?.Invoke(@thing!, @stuff!);
									break;
								}
							}
							
							if (!@foundMatch)
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
							}
						}
						else
						{
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
						}
					}
					
					private global::IUsesThingCreateExpectations Expectations { get; }
				}
				
				internal sealed class MethodExpectations
				{
					internal MethodExpectations(global::IUsesThingCreateExpectations expectations) =>
						this.Expectations = expectations;
					
					internal global::IUsesThingCreateExpectations.Adornments.AdornmentsForHandler0 Use(global::Rocks.Argument<global::Namespace2.Thing> @thing, global::Rocks.Argument<global::Namespace1.Stuff> @stuff)
					{
						global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
						global::System.ArgumentNullException.ThrowIfNull(@thing);
						global::System.ArgumentNullException.ThrowIfNull(@stuff);
						
						var @handler = new global::IUsesThingCreateExpectations.Handler0
						{
							@thing = @thing,
							@stuff = @stuff,
						};
						
						if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
						else { this.Expectations.handlers0.Add(@handler); }
						return new(@handler);
					}
					
					private global::IUsesThingCreateExpectations Expectations { get; }
				}
				
				internal global::IUsesThingCreateExpectations.MethodExpectations Methods { get; }
				
				internal IUsesThingCreateExpectations() =>
					(this.Methods) = (new(this));
				
				internal global::IUsesThing Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIUsesThing<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIUsesThing<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IUsesThingCreateExpectations.Handler0, global::System.Action<global::Namespace2.Thing, global::Namespace1.Stuff>>, IAdornmentsForIUsesThing<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IUsesThingCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IUsesThing_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWithArrayAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<IUseMethodInformation>]

			public class MethodInformation { }

			public interface IUseMethodInformation
			{
				MethodInformation[] Methods { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IUseMethodInformationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::MethodInformation[]>, global::MethodInformation[]>
				{ }
				private global::Rocks.Handlers<global::IUseMethodInformationCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IUseMethodInformation
				{
					public Mock(global::IUseMethodInformationCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public global::MethodInformation[] Methods
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)})");
						}
					}
					
					private global::IUseMethodInformationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IUseMethodInformationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IUseMethodInformationCreateExpectations.Adornments.AdornmentsForHandler0 Methods()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IUseMethodInformationCreateExpectations.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IUseMethodInformationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IUseMethodInformationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IUseMethodInformationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				
				internal global::IUseMethodInformationCreateExpectations.PropertyExpectations Properties { get; }
				
				internal IUseMethodInformationCreateExpectations() =>
					(this.Properties) = (new(this));
				
				internal global::IUseMethodInformation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIUseMethodInformation<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIUseMethodInformation<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IUseMethodInformationCreateExpectations.Handler0, global::System.Func<global::MethodInformation[]>, global::MethodInformation[]>, IAdornmentsForIUseMethodInformation<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IUseMethodInformationCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IUseMethodInformation_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWithNestedTypeAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<IOperation>]

			public interface IOperation
			{
				public struct OperationList { }

				OperationList Operations { get; }
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			internal sealed class IOperationCreateExpectations
				: global::Rocks.Expectations
			{
				internal sealed class Handler0
					: global::Rocks.Handler<global::System.Func<global::IOperation.OperationList>, global::IOperation.OperationList>
				{ }
				private global::Rocks.Handlers<global::IOperationCreateExpectations.Handler0>? @handlers0;
				
				public override void Verify()
				{
					if (this.WasInstanceInvoked)
					{
						var failures = new global::System.Collections.Generic.List<string>();
				
						if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
				
						if (failures.Count > 0)
						{
							throw new global::Rocks.Exceptions.VerificationException(failures);
						}
					}
				}
				
				private sealed class Mock
					: global::IOperation
				{
					public Mock(global::IOperationCreateExpectations @expectations)
					{
						this.Expectations = @expectations;
					}
					
					[global::Rocks.MemberIdentifier(0, global::Rocks.PropertyAccessor.Get)]
					public global::IOperation.OperationList Operations
					{
						get
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @handler = this.Expectations.handlers0.First;
								@handler.CallCount++;
								var @result = @handler.Callback is not null ?
									@handler.Callback() : @handler.ReturnValue;
								return @result!;
							}
							
							throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)})");
						}
					}
					
					private global::IOperationCreateExpectations Expectations { get; }
				}
				internal sealed class PropertyExpectations
				{
					internal sealed class PropertyGetterExpectations
					{
						internal PropertyGetterExpectations(global::IOperationCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::IOperationCreateExpectations.Adornments.AdornmentsForHandler0 Operations()
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							var handler = new global::IOperationCreateExpectations.Handler0();
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(handler); }
							else { this.Expectations.handlers0.Add(handler); }
							return new(handler);
						}
						private global::IOperationCreateExpectations Expectations { get; }
					}
					
					
					internal PropertyExpectations(global::IOperationCreateExpectations expectations) =>
						(this.Getters) = (new(expectations));
					
					internal global::IOperationCreateExpectations.PropertyExpectations.PropertyGetterExpectations Getters { get; }
				}
				
				internal global::IOperationCreateExpectations.PropertyExpectations Properties { get; }
				
				internal IOperationCreateExpectations() =>
					(this.Properties) = (new(this));
				
				internal global::IOperation Instance()
				{
					if (!this.WasInstanceInvoked)
					{
						this.WasInstanceInvoked = true;
						var @mock = new Mock(this);
						this.MockType = @mock.GetType();
						return @mock;
					}
					else
					{
						throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
					}
				}
				
				internal static class Adornments
				{
					public interface IAdornmentsForIOperation<TAdornments>
						: global::Rocks.IAdornments<TAdornments>
						where TAdornments : IAdornmentsForIOperation<TAdornments>
					{ }
					
					public sealed class AdornmentsForHandler0
						: global::Rocks.Adornments<AdornmentsForHandler0, global::IOperationCreateExpectations.Handler0, global::System.Func<global::IOperation.OperationList>, global::IOperation.OperationList>, IAdornmentsForIOperation<AdornmentsForHandler0>
					{
						public AdornmentsForHandler0(global::IOperationCreateExpectations.Handler0 handler)
							: base(handler) { }
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "IOperation_Rock_Create.g.cs", generatedCode)],
			[]);
	}

	[Test]
	public static async Task GenerateWithConstraintAsync()
	{
		var code =
			"""
			using Rocks;
			using System;

			[assembly: RockCreate<Namespace2.IUseConstraint>]

			namespace Namespace1
			{
				public interface IConstraint { }
			}

			namespace Namespace2
			{
				public interface IUseConstraint
				{
					void Foo<T>(T value) where T : Namespace1.IConstraint;
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#pragma warning disable CS8618
			#pragma warning disable CS8633
			#pragma warning disable CS8714
			#pragma warning disable CS8775
			
			#nullable enable
			
			using Rocks.Extensions;
			
			namespace Namespace2
			{
				internal sealed class IUseConstraintCreateExpectations
					: global::Rocks.Expectations
				{
					internal sealed class Handler0<T>
						: global::Rocks.Handler<global::System.Action<T>>
						where T : global::Namespace1.IConstraint
					{
						public global::Rocks.Argument<T> @value { get; set; }
					}
					private global::Rocks.Handlers<global::Rocks.Handler>? @handlers0;
					
					public override void Verify()
					{
						if (this.WasInstanceInvoked)
						{
							var failures = new global::System.Collections.Generic.List<string>();
					
							if (this.handlers0 is not null) { failures.AddRange(this.Verify(this.handlers0, 0)); }
					
							if (failures.Count > 0)
							{
								throw new global::Rocks.Exceptions.VerificationException(failures);
							}
						}
					}
					
					private sealed class Mock
						: global::Namespace2.IUseConstraint
					{
						public Mock(global::Namespace2.IUseConstraintCreateExpectations @expectations)
						{
							this.Expectations = @expectations;
						}
						
						[global::Rocks.MemberIdentifier(0)]
						public void Foo<T>(T @value)
							where T : global::Namespace1.IConstraint
						{
							if (this.Expectations.handlers0 is not null)
							{
								var @foundMatch = false;
								
								foreach (var @genericHandler in this.Expectations.handlers0)
								{
									if (@genericHandler is global::Namespace2.IUseConstraintCreateExpectations.Handler0<T> @handler)
									{
										if (@handler.@value.IsValid(@value!))
										{
											@foundMatch = true;
											@handler.CallCount++;
											@handler.Callback?.Invoke(@value!);
											break;
										}
									}
								}
								
								if (!@foundMatch)
								{
									throw new global::Rocks.Exceptions.ExpectationException($"No handlers match for {this.GetType().GetMemberDescription(0)}");
								}
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException($"No handlers were found for {this.GetType().GetMemberDescription(0)}");
							}
						}
						
						private global::Namespace2.IUseConstraintCreateExpectations Expectations { get; }
					}
					
					internal sealed class MethodExpectations
					{
						internal MethodExpectations(global::Namespace2.IUseConstraintCreateExpectations expectations) =>
							this.Expectations = expectations;
						
						internal global::Namespace2.IUseConstraintCreateExpectations.Adornments.AdornmentsForHandler0<T> Foo<T>(global::Rocks.Argument<T> @value) where T : global::Namespace1.IConstraint
						{
							global::Rocks.Exceptions.ExpectationException.ThrowIf(this.Expectations.WasInstanceInvoked);
							global::System.ArgumentNullException.ThrowIfNull(@value);
							
							var @handler = new global::Namespace2.IUseConstraintCreateExpectations.Handler0<T>
							{
								@value = @value,
							};
							
							if (this.Expectations.handlers0 is null) { this.Expectations.handlers0 = new(@handler); }
							else { this.Expectations.handlers0.Add(@handler); }
							return new(@handler);
						}
						
						private global::Namespace2.IUseConstraintCreateExpectations Expectations { get; }
					}
					
					internal global::Namespace2.IUseConstraintCreateExpectations.MethodExpectations Methods { get; }
					
					internal IUseConstraintCreateExpectations() =>
						(this.Methods) = (new(this));
					
					internal global::Namespace2.IUseConstraint Instance()
					{
						if (!this.WasInstanceInvoked)
						{
							this.WasInstanceInvoked = true;
							var @mock = new Mock(this);
							this.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
					
					internal static class Adornments
					{
						public interface IAdornmentsForIUseConstraint<TAdornments>
							: global::Rocks.IAdornments<TAdornments>
							where TAdornments : IAdornmentsForIUseConstraint<TAdornments>
						{ }
						
						public sealed class AdornmentsForHandler0<T>
							: global::Rocks.Adornments<AdornmentsForHandler0<T>, global::Namespace2.IUseConstraintCreateExpectations.Handler0<T>, global::System.Action<T>>, IAdornmentsForIUseConstraint<AdornmentsForHandler0<T>> where T : global::Namespace1.IConstraint
						{
							public AdornmentsForHandler0(global::Namespace2.IUseConstraintCreateExpectations.Handler0<T> handler)
								: base(handler) { }
						}
					}
				}
			}
			
			#pragma warning restore CS8618
			#pragma warning restore CS8633
			#pragma warning restore CS8714
			#pragma warning restore CS8775
			""";

		await TestAssistants.RunGeneratorAsync<RockAttributeGenerator>(code,
			[(typeof(RockAttributeGenerator), "Namespace2.IUseConstraint_Rock_Create.g.cs", generatedCode)],
			[]);
	}
}