using Microsoft.CodeAnalysis.Testing;
using NUnit.Framework;

namespace Rocks.Tests.Generators;

public static class MethodGeneratorTests
{
	[Test]
	public static async Task GenerateWhenOptionalArgumentsExistAsync()
	{
		var code =
			"""
			using Rocks;

			namespace MockTests
			{
				public interface IHaveOptionalArguments
				{
					void Foo(int a, string b = "b", double c = 3.2);
				}
			
				public static class Test
				{
					public static void Generate()
					{
						var rock = Rock.Create<IHaveOptionalArguments>();
					}
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			using System.Collections.Generic;
			using System.Collections.Immutable;
			
			namespace MockTests
			{
				internal static class CreateExpectationsOfIHaveOptionalArgumentsExtensions
				{
					internal static global::Rocks.Expectations.MethodExpectations<global::MockTests.IHaveOptionalArguments> Methods(this global::Rocks.Expectations.Expectations<global::MockTests.IHaveOptionalArguments> @self) =>
						new(@self);
					
					internal static global::MockTests.IHaveOptionalArguments Instance(this global::Rocks.Expectations.Expectations<global::MockTests.IHaveOptionalArguments> @self)
					{
						if (!@self.WasInstanceInvoked)
						{
							@self.WasInstanceInvoked = true;
							var @mock = new RockIHaveOptionalArguments(@self);
							@self.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
					
					private sealed class RockIHaveOptionalArguments
						: global::MockTests.IHaveOptionalArguments
					{
						private readonly global::System.Collections.Generic.Dictionary<int, global::System.Collections.Generic.List<global::Rocks.HandlerInformation>> handlers;
						
						public RockIHaveOptionalArguments(global::Rocks.Expectations.Expectations<global::MockTests.IHaveOptionalArguments> @expectations)
						{
							this.handlers = @expectations.Handlers;
						}
						
						[global::Rocks.MemberIdentifier(0, "void Foo(int @a, string @b, double @c)")]
						public void Foo(int @a, string @b = "b", double @c = 3.2)
						{
							if (this.handlers.TryGetValue(0, out var @methodHandlers))
							{
								var @foundMatch = false;
								
								foreach (var @methodHandler in @methodHandlers)
								{
									if (((global::Rocks.Argument<int>)@methodHandler.Expectations[0]).IsValid(@a) &&
										((global::Rocks.Argument<string>)@methodHandler.Expectations[1]).IsValid(@b) &&
										((global::Rocks.Argument<double>)@methodHandler.Expectations[2]).IsValid(@c))
									{
										@foundMatch = true;
										
										@methodHandler.IncrementCallCount();
										if (@methodHandler.Method is not null)
										{
											((global::System.Action<int, string, double>)@methodHandler.Method)(@a, @b, @c);
										}
										break;
									}
								}
								
								if (!@foundMatch)
								{
									throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Foo(int @a, string @b = \"b\", double @c = 3.2)");
								}
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Foo(int @a, string @b = \"b\", double @c = 3.2)");
							}
						}
						
					}
				}
				
				internal static class MethodExpectationsOfIHaveOptionalArgumentsExtensions
				{
					internal static global::Rocks.MethodAdornments<global::MockTests.IHaveOptionalArguments, global::System.Action<int, string, double>> Foo(this global::Rocks.Expectations.MethodExpectations<global::MockTests.IHaveOptionalArguments> @self, global::Rocks.Argument<int> @a, global::Rocks.Argument<string> @b, global::Rocks.Argument<double> @c)
					{
						global::System.ArgumentNullException.ThrowIfNull(@a);
						global::System.ArgumentNullException.ThrowIfNull(@b);
						global::System.ArgumentNullException.ThrowIfNull(@c);
						return new global::Rocks.MethodAdornments<global::MockTests.IHaveOptionalArguments, global::System.Action<int, string, double>>(@self.Add(0, new global::System.Collections.Generic.List<global::Rocks.Argument>(3) { @a, @b.Transform("b"), @c.Transform(3.2) }));
					}
					internal static global::Rocks.MethodAdornments<global::MockTests.IHaveOptionalArguments, global::System.Action<int, string, double>> Foo(this global::Rocks.Expectations.MethodExpectations<global::MockTests.IHaveOptionalArguments> @self, global::Rocks.Argument<int> @a, [global::System.Runtime.InteropServices.Optional, global::System.Runtime.InteropServices.DefaultParameterValue("b")] string @b, [global::System.Runtime.InteropServices.Optional, global::System.Runtime.InteropServices.DefaultParameterValue(3.2)] double @c) =>
						@self.Foo(@a, global::Rocks.Arg.Is(@b), global::Rocks.Arg.Is(@c));
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockCreateGenerator>(code,
			new[] { (typeof(RockCreateGenerator), "MockTests.IHaveOptionalArguments_Rock_Create.g.cs", generatedCode) },
			Enumerable.Empty<DiagnosticResult>()).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenOptionalArgumentsAndParamsExistAsync()
	{
		var code =
			"""
			using Rocks;
			using System;
			
			namespace MockTests
			{
				public interface IProjection
				{
					 void Project(string a, int b = 22, params Guid[] values);
				}

				public static class Test
				{
					public static void Generate()
					{
						var rock = Rock.Create<IProjection>();
					}
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using Rocks.Extensions;
			using System.Collections.Generic;
			using System.Collections.Immutable;
			
			namespace MockTests
			{
				internal static class CreateExpectationsOfIProjectionExtensions
				{
					internal static global::Rocks.Expectations.MethodExpectations<global::MockTests.IProjection> Methods(this global::Rocks.Expectations.Expectations<global::MockTests.IProjection> @self) =>
						new(@self);
					
					internal static global::MockTests.IProjection Instance(this global::Rocks.Expectations.Expectations<global::MockTests.IProjection> @self)
					{
						if (!@self.WasInstanceInvoked)
						{
							@self.WasInstanceInvoked = true;
							var @mock = new RockIProjection(@self);
							@self.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
					
					private sealed class RockIProjection
						: global::MockTests.IProjection
					{
						private readonly global::System.Collections.Generic.Dictionary<int, global::System.Collections.Generic.List<global::Rocks.HandlerInformation>> handlers;
						
						public RockIProjection(global::Rocks.Expectations.Expectations<global::MockTests.IProjection> @expectations)
						{
							this.handlers = @expectations.Handlers;
						}
						
						[global::Rocks.MemberIdentifier(0, "void Project(string @a, int @b, params global::System.Guid[] @values)")]
						public void Project(string @a, int @b = 22, params global::System.Guid[] @values)
						{
							if (this.handlers.TryGetValue(0, out var @methodHandlers))
							{
								var @foundMatch = false;
								
								foreach (var @methodHandler in @methodHandlers)
								{
									if (((global::Rocks.Argument<string>)@methodHandler.Expectations[0]).IsValid(@a) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[1]).IsValid(@b) &&
										((global::Rocks.Argument<global::System.Guid[]>)@methodHandler.Expectations[2]).IsValid(@values))
									{
										@foundMatch = true;
										
										@methodHandler.IncrementCallCount();
										if (@methodHandler.Method is not null)
										{
											((global::System.Action<string, int, global::System.Guid[]>)@methodHandler.Method)(@a, @b, @values);
										}
										break;
									}
								}
								
								if (!@foundMatch)
								{
									throw new global::Rocks.Exceptions.ExpectationException("No handlers match for void Project(string @a, int @b = 22, params global::System.Guid[] @values)");
								}
							}
							else
							{
								throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for void Project(string @a, int @b = 22, params global::System.Guid[] @values)");
							}
						}
						
					}
				}
				
				internal static class MethodExpectationsOfIProjectionExtensions
				{
					internal static global::Rocks.MethodAdornments<global::MockTests.IProjection, global::System.Action<string, int, global::System.Guid[]>> Project(this global::Rocks.Expectations.MethodExpectations<global::MockTests.IProjection> @self, global::Rocks.Argument<string> @a, global::Rocks.Argument<int> @b, global::Rocks.Argument<global::System.Guid[]> @values)
					{
						global::System.ArgumentNullException.ThrowIfNull(@a);
						global::System.ArgumentNullException.ThrowIfNull(@b);
						global::System.ArgumentNullException.ThrowIfNull(@values);
						return new global::Rocks.MethodAdornments<global::MockTests.IProjection, global::System.Action<string, int, global::System.Guid[]>>(@self.Add(0, new global::System.Collections.Generic.List<global::Rocks.Argument>(3) { @a, @b.Transform(22), @values }));
					}
					internal static global::Rocks.MethodAdornments<global::MockTests.IProjection, global::System.Action<string, int, global::System.Guid[]>> Project(this global::Rocks.Expectations.MethodExpectations<global::MockTests.IProjection> @self, global::Rocks.Argument<string> @a, int @b = 22, global::Rocks.Argument<global::System.Guid[]> @values) =>
						@self.Project(@a, global::Rocks.Arg.Is(@b), @values);
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockCreateGenerator>(code,
			new[] { (typeof(RockCreateGenerator), "MockTests.IProjection_Rock_Create.g.cs", generatedCode) },
			Enumerable.Empty<DiagnosticResult>()).ConfigureAwait(false);
	}

	[Test]
	public static async Task GenerateWhenMethodHasOver16ParametersAsync()
	{
		var code =
			"""
			using Rocks;

			namespace MockTests
			{
				public interface IHaveTooMuch
				{
					int AddProperty(
						int i0, int i1, int i2, int i3, int i4,
						int i5, int i6, int i7, int i8, int i9,
						int i10, int i11, int i12, int i13, int i14,
						int i15, int i16, int i17, int i18, int i19);
				}

				public static class Test
				{
					public static void Generate()
					{
						var rock = Rock.Create<IHaveTooMuch>();
					}
				}
			}
			""";

		var generatedCode =
			"""
			// <auto-generated/>
			
			#nullable enable
			
			using MockTests.ProjectionsForIHaveTooMuch;
			using Rocks.Extensions;
			using System.Collections.Generic;
			using System.Collections.Immutable;
			
			namespace MockTests
			{
				namespace ProjectionsForIHaveTooMuch
				{
					internal delegate int AddPropertyCallback_72853676484114143792518254191874903532168788273(int @i0, int @i1, int @i2, int @i3, int @i4, int @i5, int @i6, int @i7, int @i8, int @i9, int @i10, int @i11, int @i12, int @i13, int @i14, int @i15, int @i16, int @i17, int @i18, int @i19);
				}
				
				internal static class CreateExpectationsOfIHaveTooMuchExtensions
				{
					internal static global::Rocks.Expectations.MethodExpectations<global::MockTests.IHaveTooMuch> Methods(this global::Rocks.Expectations.Expectations<global::MockTests.IHaveTooMuch> @self) =>
						new(@self);
					
					internal static global::MockTests.IHaveTooMuch Instance(this global::Rocks.Expectations.Expectations<global::MockTests.IHaveTooMuch> @self)
					{
						if (!@self.WasInstanceInvoked)
						{
							@self.WasInstanceInvoked = true;
							var @mock = new RockIHaveTooMuch(@self);
							@self.MockType = @mock.GetType();
							return @mock;
						}
						else
						{
							throw new global::Rocks.Exceptions.NewMockInstanceException("Can only create a new mock once.");
						}
					}
					
					private sealed class RockIHaveTooMuch
						: global::MockTests.IHaveTooMuch
					{
						private readonly global::System.Collections.Generic.Dictionary<int, global::System.Collections.Generic.List<global::Rocks.HandlerInformation>> handlers;
						
						public RockIHaveTooMuch(global::Rocks.Expectations.Expectations<global::MockTests.IHaveTooMuch> @expectations)
						{
							this.handlers = @expectations.Handlers;
						}
						
						[global::Rocks.MemberIdentifier(0, "int AddProperty(int @i0, int @i1, int @i2, int @i3, int @i4, int @i5, int @i6, int @i7, int @i8, int @i9, int @i10, int @i11, int @i12, int @i13, int @i14, int @i15, int @i16, int @i17, int @i18, int @i19)")]
						public int AddProperty(int @i0, int @i1, int @i2, int @i3, int @i4, int @i5, int @i6, int @i7, int @i8, int @i9, int @i10, int @i11, int @i12, int @i13, int @i14, int @i15, int @i16, int @i17, int @i18, int @i19)
						{
							if (this.handlers.TryGetValue(0, out var @methodHandlers))
							{
								foreach (var @methodHandler in @methodHandlers)
								{
									if (((global::Rocks.Argument<int>)@methodHandler.Expectations[0]).IsValid(@i0) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[1]).IsValid(@i1) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[2]).IsValid(@i2) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[3]).IsValid(@i3) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[4]).IsValid(@i4) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[5]).IsValid(@i5) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[6]).IsValid(@i6) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[7]).IsValid(@i7) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[8]).IsValid(@i8) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[9]).IsValid(@i9) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[10]).IsValid(@i10) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[11]).IsValid(@i11) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[12]).IsValid(@i12) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[13]).IsValid(@i13) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[14]).IsValid(@i14) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[15]).IsValid(@i15) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[16]).IsValid(@i16) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[17]).IsValid(@i17) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[18]).IsValid(@i18) &&
										((global::Rocks.Argument<int>)@methodHandler.Expectations[19]).IsValid(@i19))
									{
										@methodHandler.IncrementCallCount();
										var @result = @methodHandler.Method is not null ?
											((global::MockTests.ProjectionsForIHaveTooMuch.AddPropertyCallback_72853676484114143792518254191874903532168788273)@methodHandler.Method)(@i0, @i1, @i2, @i3, @i4, @i5, @i6, @i7, @i8, @i9, @i10, @i11, @i12, @i13, @i14, @i15, @i16, @i17, @i18, @i19) :
											((global::Rocks.HandlerInformation<int>)@methodHandler).ReturnValue;
										return @result!;
									}
								}
								
								throw new global::Rocks.Exceptions.ExpectationException("No handlers match for int AddProperty(int @i0, int @i1, int @i2, int @i3, int @i4, int @i5, int @i6, int @i7, int @i8, int @i9, int @i10, int @i11, int @i12, int @i13, int @i14, int @i15, int @i16, int @i17, int @i18, int @i19)");
							}
							
							throw new global::Rocks.Exceptions.ExpectationException("No handlers were found for int AddProperty(int @i0, int @i1, int @i2, int @i3, int @i4, int @i5, int @i6, int @i7, int @i8, int @i9, int @i10, int @i11, int @i12, int @i13, int @i14, int @i15, int @i16, int @i17, int @i18, int @i19)");
						}
						
					}
				}
				
				internal static class MethodExpectationsOfIHaveTooMuchExtensions
				{
					internal static global::Rocks.MethodAdornments<global::MockTests.IHaveTooMuch, global::MockTests.ProjectionsForIHaveTooMuch.AddPropertyCallback_72853676484114143792518254191874903532168788273, int> AddProperty(this global::Rocks.Expectations.MethodExpectations<global::MockTests.IHaveTooMuch> @self, global::Rocks.Argument<int> @i0, global::Rocks.Argument<int> @i1, global::Rocks.Argument<int> @i2, global::Rocks.Argument<int> @i3, global::Rocks.Argument<int> @i4, global::Rocks.Argument<int> @i5, global::Rocks.Argument<int> @i6, global::Rocks.Argument<int> @i7, global::Rocks.Argument<int> @i8, global::Rocks.Argument<int> @i9, global::Rocks.Argument<int> @i10, global::Rocks.Argument<int> @i11, global::Rocks.Argument<int> @i12, global::Rocks.Argument<int> @i13, global::Rocks.Argument<int> @i14, global::Rocks.Argument<int> @i15, global::Rocks.Argument<int> @i16, global::Rocks.Argument<int> @i17, global::Rocks.Argument<int> @i18, global::Rocks.Argument<int> @i19)
					{
						global::System.ArgumentNullException.ThrowIfNull(@i0);
						global::System.ArgumentNullException.ThrowIfNull(@i1);
						global::System.ArgumentNullException.ThrowIfNull(@i2);
						global::System.ArgumentNullException.ThrowIfNull(@i3);
						global::System.ArgumentNullException.ThrowIfNull(@i4);
						global::System.ArgumentNullException.ThrowIfNull(@i5);
						global::System.ArgumentNullException.ThrowIfNull(@i6);
						global::System.ArgumentNullException.ThrowIfNull(@i7);
						global::System.ArgumentNullException.ThrowIfNull(@i8);
						global::System.ArgumentNullException.ThrowIfNull(@i9);
						global::System.ArgumentNullException.ThrowIfNull(@i10);
						global::System.ArgumentNullException.ThrowIfNull(@i11);
						global::System.ArgumentNullException.ThrowIfNull(@i12);
						global::System.ArgumentNullException.ThrowIfNull(@i13);
						global::System.ArgumentNullException.ThrowIfNull(@i14);
						global::System.ArgumentNullException.ThrowIfNull(@i15);
						global::System.ArgumentNullException.ThrowIfNull(@i16);
						global::System.ArgumentNullException.ThrowIfNull(@i17);
						global::System.ArgumentNullException.ThrowIfNull(@i18);
						global::System.ArgumentNullException.ThrowIfNull(@i19);
						return new global::Rocks.MethodAdornments<global::MockTests.IHaveTooMuch, global::MockTests.ProjectionsForIHaveTooMuch.AddPropertyCallback_72853676484114143792518254191874903532168788273, int>(@self.Add<int>(0, new global::System.Collections.Generic.List<global::Rocks.Argument>(20) { @i0, @i1, @i2, @i3, @i4, @i5, @i6, @i7, @i8, @i9, @i10, @i11, @i12, @i13, @i14, @i15, @i16, @i17, @i18, @i19 }));
					}
				}
			}
			
			""";

		await TestAssistants.RunAsync<RockCreateGenerator>(code,
			new[] { (typeof(RockCreateGenerator), "MockTests.IHaveTooMuch_Rock_Create.g.cs", generatedCode) },
			Enumerable.Empty<DiagnosticResult>()).ConfigureAwait(false);
	}
}